{"version":3,"file":"reference.js","sourceRoot":"","sources":["../../../../src/lib/converter/factories/reference.ts"],"names":[],"mappings":";;AAEA,yCAAuG;AAEvG,kEAAoE;AACpE,4CAAyC;AAUzC,SAAgB,mBAAmB,CAAC,OAAgB,EAAE,MAA6B,EAAE,aAAuB;IACxG,IAAI,CAAC,MAAM,EAAE;QACT,OAAO;KACV;IAED,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IAChC,IAAI,IAAI,GAAG,OAAO,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;IAE1C,IAAI,aAAa,IAAI,MAAM,CAAC,MAAM,EAAE;QAChC,IAAI,GAAG,OAAO,CAAC,cAAc,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC;KAC7D;IAED,OAAO,IAAI,sBAAa,CAAC,IAAI,EAAE,OAAO,CAAC,OAAO,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC,CAAC;AAClF,CAAC;AAbD,kDAaC;AAED,SAAgB,yBAAyB,CAAC,OAAgB,EAAE,MAAiB,EAAE,MAAiB;IAC5F,IAAI,CAAC,CAAC,OAAO,CAAC,KAAK,YAAY,4BAAmB,CAAC,EAAE;QACjD,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;KAC9D;IAID,IAAI,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,sBAAsB,CAAC,CAAC,CAAC,aAAa,EAAE,CAAC,QAAQ,CAAC,CAAC,EAAE;QAC3F,OAAO;KACV;IAED,MAAM,UAAU,GAAG,IAAI,4BAAmB,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,0BAAc,CAAC,UAAU,EAAE,OAAO,CAAC,OAAO,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;IACnJ,UAAU,CAAC,KAAK,CAAC,OAAO,CAAC,uBAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IACxD,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,EAAE;QACzB,OAAO,CAAC,KAAK,CAAC,QAAQ,GAAG,EAAE,CAAC;KAC/B;IACD,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IAIxC,OAAO,CAAC,kBAAkB,CAAC,UAAU,EAAE,MAAM,KAAK,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;IAC/E,OAAO,CAAC,OAAO,CAAC,qBAAS,CAAC,wBAAwB,EAAE,UAAU,CAAC,CAAC;IAEhE,OAAO,UAAU,CAAC;AACtB,CAAC;AAxBD,8DAwBC","sourcesContent":["import * as ts from 'typescript';\n\nimport { ReferenceType, ReferenceReflection, ContainerReflection, ReflectionFlag } from '../../models';\nimport { Context } from '../context';\nimport { ReferenceState } from '../../models/reflections/reference';\nimport { Converter } from '../converter';\n\n/**\n * Create a new reference type pointing to the given symbol.\n *\n * @param context  The context object describing the current state the converter is in.\n * @param symbol  The symbol the reference type should point to.\n * @param includeParent  Should the name of the parent be provided within the fallback name?\n * @returns A new reference type instance pointing to the given symbol.\n */\nexport function createReferenceType(context: Context, symbol: ts.Symbol | undefined, includeParent?: boolean): ReferenceType | undefined {\n    if (!symbol) {\n        return;\n    }\n\n    const checker = context.checker;\n    let name = checker.symbolToString(symbol);\n\n    if (includeParent && symbol.parent) {\n        name = checker.symbolToString(symbol.parent) + '.' + name;\n    }\n\n    return new ReferenceType(name, context.checker.getFullyQualifiedName(symbol));\n}\n\nexport function createReferenceReflection(context: Context, source: ts.Symbol, target: ts.Symbol): ReferenceReflection | undefined {\n    if (!(context.scope instanceof ContainerReflection)) {\n        throw new Error('Cannot add reference to a non-container');\n    }\n\n    // If any declaration is outside, the symbol should be considered outside. Some declarations may\n    // be inside due to declaration merging.\n    if (target.declarations.some(d => context.isOutsideDocumentation(d.getSourceFile().fileName))) {\n        return;\n    }\n\n    const reflection = new ReferenceReflection(source.name, [ReferenceState.Unresolved, context.checker.getFullyQualifiedName(target)], context.scope);\n    reflection.flags.setFlag(ReflectionFlag.Exported, true); // References are exported by necessity\n    if (!context.scope.children) {\n        context.scope.children = [];\n    }\n    context.scope.children.push(reflection);\n\n    // target === source happens when doing export * from ...\n    // and the original symbol is not renamed and exported from the imported module.\n    context.registerReflection(reflection, target === source ? undefined : source);\n    context.trigger(Converter.EVENT_CREATE_DECLARATION, reflection);\n\n    return reflection;\n}\n"]}
{"version":3,"file":"signature.js","sourceRoot":"","sources":["../../../../src/lib/converter/factories/signature.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from \"typescript\";\nimport * as assert from \"assert\";\nimport {\n    DeclarationReflection,\n    ParameterReflection,\n    PredicateType,\n    Reflection,\n    ReflectionFlag,\n    ReflectionKind,\n    SignatureReflection,\n    TypeParameterReflection,\n} from \"../../models\";\nimport { Context } from \"../context\";\nimport { ConverterEvents } from \"../converter-events\";\nimport { convertDefaultValue } from \"../convert-expression\";\nimport { removeUndefined } from \"../utils/reflections\";\n\nexport function createSignature(\n    context: Context,\n    kind:\n        | ReflectionKind.CallSignature\n        | ReflectionKind.ConstructorSignature\n        | ReflectionKind.GetSignature\n        | ReflectionKind.SetSignature,\n    signature: ts.Signature,\n    declaration?: ts.SignatureDeclaration,\n    commentDeclaration?: ts.Node\n) {\n    assert(context.scope instanceof DeclarationReflection);\n    // signature.getDeclaration might return undefined.\n    // https://github.com/microsoft/TypeScript/issues/30014\n    declaration ??= signature.getDeclaration() as\n        | ts.SignatureDeclaration\n        | undefined;\n\n    if (\n        !commentDeclaration &&\n        declaration &&\n        (ts.isArrowFunction(declaration) ||\n            ts.isFunctionExpression(declaration))\n    ) {\n        commentDeclaration = declaration.parent;\n    }\n    commentDeclaration ??= declaration;\n\n    const sigRef = new SignatureReflection(\n        context.scope.name,\n        kind,\n        context.scope\n    );\n\n    sigRef.typeParameters = convertTypeParameters(\n        context,\n        sigRef,\n        signature.typeParameters\n    );\n\n    sigRef.parameters = convertParameters(\n        context,\n        sigRef,\n        signature.parameters as readonly (ts.Symbol & { type: ts.Type })[],\n        declaration?.parameters\n    );\n\n    const predicate = context.checker.getTypePredicateOfSignature(signature);\n    if (predicate) {\n        sigRef.type = convertPredicate(predicate, context.withScope(sigRef));\n    } else {\n        sigRef.type = context.converter.convertType(\n            context.withScope(sigRef),\n            (declaration?.kind === ts.SyntaxKind.FunctionDeclaration &&\n                declaration.type) ||\n                signature.getReturnType()\n        );\n    }\n\n    context.registerReflection(sigRef, undefined);\n    context.trigger(\n        ConverterEvents.CREATE_SIGNATURE,\n        sigRef,\n        commentDeclaration\n    );\n    return sigRef;\n}\n\nfunction convertParameters(\n    context: Context,\n    sigRef: SignatureReflection,\n    parameters: readonly (ts.Symbol & { type: ts.Type })[],\n    parameterNodes: readonly ts.ParameterDeclaration[] | undefined\n) {\n    return parameters.map((param, i) => {\n        const declaration = param.valueDeclaration as\n            | ts.Declaration\n            | undefined;\n        assert(\n            !declaration ||\n                ts.isParameter(declaration) ||\n                ts.isJSDocParameterTag(declaration)\n        );\n        const paramRefl = new ParameterReflection(\n            /__\\d+/.test(param.name) ? \"__namedParameters\" : param.name,\n            ReflectionKind.Parameter,\n            sigRef\n        );\n        context.registerReflection(paramRefl, param);\n        context.trigger(\n            ConverterEvents.CREATE_PARAMETER,\n            paramRefl,\n            declaration\n        );\n\n        let type: ts.Type | ts.TypeNode;\n        if (\n            declaration &&\n            ts.isParameter(declaration) &&\n            ts.isFunctionDeclaration(declaration.parent) &&\n            declaration.type\n        ) {\n            type = declaration.type;\n        } else if (declaration) {\n            type = context.checker.getTypeOfSymbolAtLocation(\n                param,\n                declaration\n            );\n        } else {\n            type = param.type;\n        }\n\n        paramRefl.type = context.converter.convertType(\n            context.withScope(paramRefl),\n            type\n        );\n\n        let isOptional = false;\n        if (declaration) {\n            isOptional = ts.isParameter(declaration)\n                ? !!declaration.questionToken\n                : declaration.isBracketed;\n        }\n\n        if (isOptional) {\n            paramRefl.type = removeUndefined(paramRefl.type);\n        }\n\n        paramRefl.defaultValue = convertDefaultValue(parameterNodes?.[i]);\n        paramRefl.setFlag(ReflectionFlag.Optional, isOptional);\n\n        // If we have no declaration, then this is an implicitly defined parameter in JS land\n        // because the method body uses `arguments`... which is always a rest argument\n        let isRest = true;\n        if (declaration) {\n            isRest = ts.isParameter(declaration)\n                ? !!declaration.dotDotDotToken\n                : !!declaration.typeExpression &&\n                  ts.isJSDocVariadicType(declaration.typeExpression.type);\n        }\n\n        paramRefl.setFlag(ReflectionFlag.Rest, isRest);\n        return paramRefl;\n    });\n}\n\nexport function convertParameterNodes(\n    context: Context,\n    sigRef: SignatureReflection,\n    parameters: readonly (ts.JSDocParameterTag | ts.ParameterDeclaration)[]\n) {\n    return parameters.map((param) => {\n        const paramRefl = new ParameterReflection(\n            /__\\d+/.test(param.name.getText())\n                ? \"__namedParameters\"\n                : param.name.getText(),\n            ReflectionKind.Parameter,\n            sigRef\n        );\n        context.registerReflection(\n            paramRefl,\n            context.getSymbolAtLocation(param)\n        );\n\n        paramRefl.type = context.converter.convertType(\n            context.withScope(paramRefl),\n            ts.isParameter(param) ? param.type : param.typeExpression?.type\n        );\n\n        const isOptional = ts.isParameter(param)\n            ? !!param.questionToken\n            : param.isBracketed;\n        if (isOptional) {\n            paramRefl.type = removeUndefined(paramRefl.type);\n        }\n\n        paramRefl.defaultValue = convertDefaultValue(param);\n        paramRefl.setFlag(ReflectionFlag.Optional, isOptional);\n        paramRefl.setFlag(\n            ReflectionFlag.Rest,\n            ts.isParameter(param)\n                ? !!param.dotDotDotToken\n                : !!param.typeExpression &&\n                      ts.isJSDocVariadicType(param.typeExpression.type)\n        );\n        return paramRefl;\n    });\n}\n\nfunction convertTypeParameters(\n    context: Context,\n    parent: Reflection,\n    parameters: readonly ts.TypeParameter[] | undefined\n) {\n    return parameters?.map((param) => {\n        const constraintT = param.getConstraint();\n        const defaultT = param.getDefault();\n\n        const constraint = constraintT\n            ? context.converter.convertType(context, constraintT)\n            : void 0;\n        const defaultType = defaultT\n            ? context.converter.convertType(context, defaultT)\n            : void 0;\n        const paramRefl = new TypeParameterReflection(\n            param.symbol.name,\n            constraint,\n            defaultType,\n            parent\n        );\n        context.registerReflection(paramRefl, undefined);\n        context.trigger(ConverterEvents.CREATE_TYPE_PARAMETER, paramRefl);\n\n        return paramRefl;\n    });\n}\n\nexport function convertTypeParameterNodes(\n    context: Context,\n    parameters: readonly ts.TypeParameterDeclaration[] | undefined\n) {\n    return parameters?.map((param) => {\n        const constraint = param.constraint\n            ? context.converter.convertType(context, param.constraint)\n            : void 0;\n        const defaultType = param.default\n            ? context.converter.convertType(context, param.default)\n            : void 0;\n        const paramRefl = new TypeParameterReflection(\n            param.name.text,\n            constraint,\n            defaultType,\n            context.scope\n        );\n        context.registerReflection(paramRefl, undefined);\n        context.trigger(\n            ConverterEvents.CREATE_TYPE_PARAMETER,\n            paramRefl,\n            param\n        );\n\n        return paramRefl;\n    });\n}\n\nfunction convertPredicate(\n    predicate: ts.TypePredicate,\n    context: Context\n): PredicateType {\n    let name: string;\n    switch (predicate.kind) {\n        case ts.TypePredicateKind.This:\n        case ts.TypePredicateKind.AssertsThis:\n            name = \"this\";\n            break;\n        case ts.TypePredicateKind.Identifier:\n        case ts.TypePredicateKind.AssertsIdentifier:\n            name = predicate.parameterName;\n            break;\n    }\n\n    let asserts: boolean;\n    switch (predicate.kind) {\n        case ts.TypePredicateKind.This:\n        case ts.TypePredicateKind.Identifier:\n            asserts = false;\n            break;\n        case ts.TypePredicateKind.AssertsThis:\n        case ts.TypePredicateKind.AssertsIdentifier:\n            asserts = true;\n            break;\n    }\n\n    return new PredicateType(\n        name,\n        asserts,\n        predicate.type\n            ? context.converter.convertType(context, predicate.type)\n            : void 0\n    );\n}\n"]}
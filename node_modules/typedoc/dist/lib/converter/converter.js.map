{"version":3,"file":"converter.js","sourceRoot":"","sources":["../../../src/lib/converter/converter.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from \"typescript\";\nimport * as _ from \"lodash\";\nimport * as assert from \"assert\";\nimport { resolve } from \"path\";\n\nimport { Application } from \"../application\";\nimport { Type, ProjectReflection, ReflectionKind } from \"../models/index\";\nimport { Context } from \"./context\";\nimport { ConverterComponent } from \"./components\";\nimport { Component, ChildableComponent } from \"../utils/component\";\nimport { BindOption, normalizePath } from \"../utils\";\nimport { convertType } from \"./types\";\nimport { ConverterEvents } from \"./converter-events\";\nimport { convertSymbol } from \"./symbols\";\nimport { relative } from \"path\";\nimport { getCommonDirectory } from \"../utils/fs\";\nimport { createMinimatch } from \"../utils/paths\";\nimport { IMinimatch } from \"minimatch\";\nimport { hasAllFlags, hasAnyFlag } from \"../utils/enum\";\nimport { resolveAliasedSymbol } from \"./utils/symbols\";\n\n/**\n * Compiles source files using TypeScript and converts compiler symbols to reflections.\n */\n@Component({\n    name: \"converter\",\n    internal: true,\n    childClass: ConverterComponent,\n})\nexport class Converter extends ChildableComponent<\n    Application,\n    ConverterComponent\n> {\n    /**\n     * The human readable name of the project. Used within the templates to set the title of the document.\n     */\n    @BindOption(\"name\")\n    name!: string;\n\n    @BindOption(\"externalPattern\")\n    externalPattern!: string[];\n    private externalPatternCache?: IMinimatch[];\n\n    @BindOption(\"excludeExternals\")\n    excludeExternals!: boolean;\n\n    @BindOption(\"excludeNotDocumented\")\n    excludeNotDocumented!: boolean;\n\n    @BindOption(\"excludePrivate\")\n    excludePrivate!: boolean;\n\n    @BindOption(\"excludeProtected\")\n    excludeProtected!: boolean;\n\n    /**\n     * General events\n     */\n\n    /**\n     * Triggered when the converter begins converting a project.\n     * The listener should implement [[IConverterCallback]].\n     * @event\n     */\n    static readonly EVENT_BEGIN = ConverterEvents.BEGIN;\n\n    /**\n     * Triggered when the converter has finished converting a project.\n     * The listener should implement [[IConverterCallback]].\n     * @event\n     */\n    static readonly EVENT_END = ConverterEvents.END;\n\n    /**\n     * Factory events\n     */\n\n    /**\n     * Triggered when the converter has created a declaration reflection.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static readonly EVENT_CREATE_DECLARATION =\n        ConverterEvents.CREATE_DECLARATION;\n\n    /**\n     * Triggered when the converter has created a signature reflection.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static readonly EVENT_CREATE_SIGNATURE = ConverterEvents.CREATE_SIGNATURE;\n\n    /**\n     * Triggered when the converter has created a parameter reflection.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static readonly EVENT_CREATE_PARAMETER = ConverterEvents.CREATE_PARAMETER;\n\n    /**\n     * Triggered when the converter has created a type parameter reflection.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static readonly EVENT_CREATE_TYPE_PARAMETER =\n        ConverterEvents.CREATE_TYPE_PARAMETER;\n\n    /**\n     * Resolve events\n     */\n\n    /**\n     * Triggered when the converter begins resolving a project.\n     * The listener should implement [[IConverterCallback]].\n     * @event\n     */\n    static readonly EVENT_RESOLVE_BEGIN = ConverterEvents.RESOLVE_BEGIN;\n\n    /**\n     * Triggered when the converter resolves a reflection.\n     * The listener should implement [[IConverterResolveCallback]].\n     * @event\n     */\n    static readonly EVENT_RESOLVE = ConverterEvents.RESOLVE;\n\n    /**\n     * Triggered when the converter has finished resolving a project.\n     * The listener should implement [[IConverterCallback]].\n     * @event\n     */\n    static readonly EVENT_RESOLVE_END = ConverterEvents.RESOLVE_END;\n\n    /**\n     * Compile the given source files and create a project reflection for them.\n     *\n     * @param entryPoints the entry points of this program.\n     * @param program the program to document that has already been type checked.\n     */\n    convert(\n        entryPoints: readonly string[],\n        programs: ts.Program | readonly ts.Program[]\n    ): ProjectReflection {\n        programs = programs instanceof Array ? programs : [programs];\n        this.externalPatternCache = void 0;\n\n        const project = new ProjectReflection(this.name);\n        const context = new Context(this, programs, project);\n\n        this.trigger(Converter.EVENT_BEGIN, context);\n\n        this.compile(entryPoints, context);\n        this.resolve(context);\n        // This should only do anything if a plugin does something bad.\n        project.removeDanglingReferences();\n\n        this.trigger(Converter.EVENT_END, context);\n\n        return project;\n    }\n\n    /** @internal */\n    convertSymbol(context: Context, symbol: ts.Symbol) {\n        convertSymbol(context, symbol);\n    }\n\n    /**\n     * Convert the given TypeScript type into its TypeDoc type reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param referenceTarget The target to be used to attempt to resolve reference types\n     * @returns The TypeDoc type reflection representing the given node and type.\n     * @internal\n     */\n    convertType(\n        context: Context,\n        node: ts.TypeNode | ts.Type | undefined\n    ): Type {\n        return convertType(context, node);\n    }\n\n    /** @internal */\n    getNodesForSymbol(symbol: ts.Symbol, kind: ReflectionKind) {\n        const wantedKinds: ts.SyntaxKind[] = {\n            [ReflectionKind.Project]: [ts.SyntaxKind.SourceFile],\n            [ReflectionKind.Module]: [ts.SyntaxKind.SourceFile],\n            [ReflectionKind.Namespace]: [\n                ts.SyntaxKind.ModuleDeclaration,\n                ts.SyntaxKind.SourceFile,\n            ],\n            [ReflectionKind.Enum]: [ts.SyntaxKind.EnumDeclaration],\n            [ReflectionKind.EnumMember]: [ts.SyntaxKind.EnumMember],\n            [ReflectionKind.Variable]: [ts.SyntaxKind.VariableDeclaration],\n            [ReflectionKind.Function]: [\n                ts.SyntaxKind.FunctionDeclaration,\n                ts.SyntaxKind.VariableDeclaration,\n            ],\n            [ReflectionKind.Class]: [ts.SyntaxKind.ClassDeclaration],\n            [ReflectionKind.Interface]: [\n                ts.SyntaxKind.InterfaceDeclaration,\n                ts.SyntaxKind.JSDocTypedefTag,\n            ],\n            [ReflectionKind.Constructor]: [ts.SyntaxKind.Constructor],\n            [ReflectionKind.Property]: [\n                ts.SyntaxKind.PropertyDeclaration,\n                ts.SyntaxKind.PropertySignature,\n                ts.SyntaxKind.JSDocPropertyTag,\n            ],\n            [ReflectionKind.Method]: [\n                ts.SyntaxKind.MethodDeclaration,\n                ts.SyntaxKind.PropertyDeclaration,\n                ts.SyntaxKind.PropertySignature,\n            ],\n            [ReflectionKind.CallSignature]: [\n                ts.SyntaxKind.FunctionDeclaration,\n                ts.SyntaxKind.VariableDeclaration,\n                ts.SyntaxKind.MethodDeclaration,\n                ts.SyntaxKind.MethodDeclaration,\n                ts.SyntaxKind.PropertyDeclaration,\n                ts.SyntaxKind.PropertySignature,\n                ts.SyntaxKind.CallSignature,\n            ],\n            [ReflectionKind.IndexSignature]: [ts.SyntaxKind.IndexSignature],\n            [ReflectionKind.ConstructorSignature]: [\n                ts.SyntaxKind.ConstructSignature,\n            ],\n            [ReflectionKind.Parameter]: [ts.SyntaxKind.Parameter],\n            [ReflectionKind.TypeLiteral]: [ts.SyntaxKind.TypeLiteral],\n            [ReflectionKind.TypeParameter]: [ts.SyntaxKind.TypeParameter],\n            [ReflectionKind.Accessor]: [\n                ts.SyntaxKind.GetAccessor,\n                ts.SyntaxKind.SetAccessor,\n            ],\n            [ReflectionKind.GetSignature]: [ts.SyntaxKind.GetAccessor],\n            [ReflectionKind.SetSignature]: [ts.SyntaxKind.SetAccessor],\n            [ReflectionKind.ObjectLiteral]: [\n                ts.SyntaxKind.ObjectLiteralExpression,\n            ],\n            [ReflectionKind.TypeAlias]: [\n                ts.SyntaxKind.TypeAliasDeclaration,\n                ts.SyntaxKind.JSDocTypedefTag,\n            ],\n            [ReflectionKind.Event]: [], /// this needs to go away\n            [ReflectionKind.Reference]: [\n                ts.SyntaxKind.NamespaceExport,\n                ts.SyntaxKind.ExportSpecifier,\n            ],\n        }[kind];\n\n        const declarations = symbol.getDeclarations() ?? [];\n        return declarations.filter((d) => wantedKinds.includes(d.kind));\n    }\n\n    /**\n     * Compile the files within the given context and convert the compiler symbols to reflections.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @returns An array containing all errors generated by the TypeScript compiler.\n     */\n    private compile(entryPoints: readonly string[], context: Context) {\n        const baseDir = getCommonDirectory(entryPoints);\n        const entries: {\n            file: string;\n            sourceFile: ts.SourceFile;\n            program: ts.Program;\n            context?: Context;\n        }[] = [];\n\n        entryLoop: for (const file of entryPoints.map(normalizePath)) {\n            for (const program of context.programs) {\n                const sourceFile = program.getSourceFile(file);\n                if (sourceFile) {\n                    entries.push({ file, sourceFile, program });\n                    continue entryLoop;\n                }\n            }\n            this.application.logger.warn(\n                `Unable to locate entry point: ${file}`\n            );\n        }\n\n        for (const entry of entries) {\n            context.setActiveProgram(entry.program);\n            entry.context = this.convertExports(\n                context,\n                entry.sourceFile,\n                entryPoints,\n                getModuleName(resolve(entry.file), baseDir)\n            );\n        }\n\n        for (const { sourceFile, context } of entries) {\n            // active program is already set on context\n            assert(context);\n            this.convertReExports(context, sourceFile);\n        }\n\n        context.setActiveProgram(undefined);\n    }\n\n    private convertExports(\n        context: Context,\n        node: ts.SourceFile,\n        entryPoints: readonly string[],\n        entryName: string\n    ) {\n        const symbol = getSymbolForModuleLike(context, node);\n        let moduleContext: Context;\n\n        if (entryPoints.length === 1) {\n            // Special case for when we're giving a single entry point, we don't need to\n            // create modules for each entry. Register the project as this module.\n            context.project.registerReflection(context.project, symbol);\n            context.trigger(\n                Converter.EVENT_CREATE_DECLARATION,\n                context.project,\n                node\n            );\n            moduleContext = context;\n        } else {\n            const reflection = context.createDeclarationReflection(\n                ReflectionKind.Module,\n                symbol,\n                entryName\n            );\n            moduleContext = context.withScope(reflection);\n        }\n\n        for (const exp of getExports(context, node, symbol).filter((exp) =>\n            isDirectExport(context.resolveAliasedSymbol(exp), node)\n        )) {\n            convertSymbol(moduleContext, exp);\n        }\n\n        return moduleContext;\n    }\n\n    private convertReExports(moduleContext: Context, node: ts.SourceFile) {\n        for (const exp of getExports(\n            moduleContext,\n            node,\n            moduleContext.project.getSymbolFromReflection(moduleContext.scope)\n        ).filter(\n            (exp) =>\n                !isDirectExport(moduleContext.resolveAliasedSymbol(exp), node)\n        )) {\n            convertSymbol(moduleContext, exp);\n        }\n    }\n\n    /**\n     * Resolve the project within the given context.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @returns The final project reflection.\n     */\n    private resolve(context: Context): void {\n        this.trigger(Converter.EVENT_RESOLVE_BEGIN, context);\n        const project = context.project;\n\n        for (const reflection of Object.values(project.reflections)) {\n            this.trigger(Converter.EVENT_RESOLVE, context, reflection);\n        }\n\n        this.trigger(Converter.EVENT_RESOLVE_END, context);\n    }\n\n    /** @internal */\n    shouldIgnore(symbol: ts.Symbol, checker: ts.TypeChecker) {\n        if (\n            this.excludeNotDocumented &&\n            // If the enum is included, we should include members even if not documented.\n            !hasAllFlags(symbol.flags, ts.SymbolFlags.EnumMember) &&\n            resolveAliasedSymbol(symbol, checker).getDocumentationComment(\n                checker\n            ).length === 0\n        ) {\n            return true;\n        }\n\n        if (!this.excludeExternals) {\n            return false;\n        }\n\n        return this.isExternal(symbol);\n    }\n\n    /** @internal */\n    isExternal(symbol: ts.Symbol) {\n        this.externalPatternCache ??= createMinimatch(this.externalPattern);\n        for (const node of symbol.getDeclarations() ?? []) {\n            if (\n                this.externalPatternCache.some((p) =>\n                    p.match(node.getSourceFile().fileName)\n                )\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nfunction getModuleName(fileName: string, baseDir: string) {\n    return normalizePath(relative(baseDir, fileName)).replace(\n        /(\\/index)?(\\.d)?\\.[tj]sx?$/,\n        \"\"\n    );\n}\n\nfunction getSymbolForModuleLike(\n    context: Context,\n    node: ts.SourceFile | ts.ModuleBlock\n) {\n    const symbol = context.checker.getSymbolAtLocation(node) ?? node.symbol;\n\n    if (symbol) {\n        return symbol;\n    }\n\n    // This is a global file, get all symbols declared in this file...\n    // this isn't the best solution, it would be nice to have all globals given to a special\n    // \"globals\" file, but this is uncommon enough that I'm skipping it for now.\n    const sourceFile = node.getSourceFile();\n    const globalSymbols = context.checker\n        .getSymbolsInScope(node, ts.SymbolFlags.ModuleMember)\n        .filter((s) =>\n            s.getDeclarations()?.some((d) => d.getSourceFile() === sourceFile)\n        );\n\n    // Detect declaration files with declare module \"foo\" as their only export\n    // and lift that up one level as the source file symbol\n    if (\n        globalSymbols.length === 1 &&\n        globalSymbols[0]\n            .getDeclarations()\n            ?.every(\n                (declaration) =>\n                    ts.isModuleDeclaration(declaration) &&\n                    ts.isStringLiteral(declaration.name)\n            )\n    ) {\n        return globalSymbols[0];\n    }\n}\n\nfunction getExports(\n    context: Context,\n    node: ts.SourceFile | ts.ModuleBlock,\n    symbol: ts.Symbol | undefined\n): ts.Symbol[] {\n    // The generated docs aren't great, but you really ought not be using\n    // this in the first place... so it's better than nothing.\n    const exportEq = symbol?.exports?.get(\"export=\" as ts.__String);\n    if (exportEq) {\n        // JS users might also have exported types here.\n        // We need to filter for types because otherwise static methods can show up as both\n        // members of the export= class and as functions if a class is directly exported.\n        return [exportEq].concat(\n            context.checker\n                .getExportsOfModule(symbol!)\n                .filter(\n                    (s) =>\n                        !hasAnyFlag(\n                            s.flags,\n                            ts.SymbolFlags.Prototype | ts.SymbolFlags.Value\n                        )\n                )\n        );\n    }\n\n    if (symbol) {\n        return context.checker\n            .getExportsOfModule(symbol)\n            .filter((s) => !hasAllFlags(s.flags, ts.SymbolFlags.Prototype));\n    }\n\n    // Global file with no inferred top level symbol, get all symbols declared in this file.\n    const sourceFile = node.getSourceFile();\n    const globalSymbols = context.checker\n        .getSymbolsInScope(node, ts.SymbolFlags.ModuleMember)\n        .filter((s) =>\n            s.getDeclarations()?.some((d) => d.getSourceFile() === sourceFile)\n        );\n\n    return globalSymbols;\n}\n\nfunction isDirectExport(symbol: ts.Symbol, file: ts.SourceFile): boolean {\n    return (\n        symbol\n            .getDeclarations()\n            ?.every((decl) => decl.getSourceFile() === file) ?? false\n    );\n}\n"]}
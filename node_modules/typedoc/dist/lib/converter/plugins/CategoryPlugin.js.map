{"version":3,"file":"CategoryPlugin.js","sourceRoot":"","sources":["../../../../src/lib/converter/plugins/CategoryPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    Reflection,\n    ContainerReflection,\n    DeclarationReflection,\n    CommentTag,\n} from \"../../models\";\nimport { ReflectionCategory } from \"../../models/ReflectionCategory\";\nimport { Component, ConverterComponent } from \"../components\";\nimport { Converter } from \"../converter\";\nimport { Context } from \"../context\";\nimport { BindOption } from \"../../utils\";\nimport { Comment } from \"../../models/comments/index\";\n\n/**\n * A handler that sorts and categorizes the found reflections in the resolving phase.\n *\n * The handler sets the ´category´ property of all reflections.\n */\n@Component({ name: \"category\" })\nexport class CategoryPlugin extends ConverterComponent {\n    @BindOption(\"defaultCategory\")\n    defaultCategory!: string;\n\n    @BindOption(\"categoryOrder\")\n    categoryOrder!: string[];\n\n    @BindOption(\"categorizeByGroup\")\n    categorizeByGroup!: boolean;\n\n    // For use in static methods\n    static defaultCategory = \"Other\";\n    static WEIGHTS: string[] = [];\n\n    /**\n     * Create a new CategoryPlugin instance.\n     */\n    initialize() {\n        this.listenTo(\n            this.owner,\n            {\n                [Converter.EVENT_BEGIN]: this.onBegin,\n                [Converter.EVENT_RESOLVE]: this.onResolve,\n                [Converter.EVENT_RESOLVE_END]: this.onEndResolve,\n            },\n            undefined,\n            -200\n        );\n    }\n\n    /**\n     * Triggered when the converter begins converting a project.\n     */\n    private onBegin(_context: Context) {\n        // Set up static properties\n        if (this.defaultCategory) {\n            CategoryPlugin.defaultCategory = this.defaultCategory;\n        }\n        if (this.categoryOrder) {\n            CategoryPlugin.WEIGHTS = this.categoryOrder;\n        }\n    }\n\n    /**\n     * Triggered when the converter resolves a reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    private onResolve(_context: Context, reflection: Reflection) {\n        if (reflection instanceof ContainerReflection) {\n            this.categorize(reflection);\n        }\n    }\n\n    /**\n     * Triggered when the converter has finished resolving a project.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     */\n    private onEndResolve(context: Context) {\n        const project = context.project;\n        this.categorize(project);\n    }\n\n    private categorize(obj: ContainerReflection) {\n        if (this.categorizeByGroup) {\n            this.groupCategorize(obj);\n        } else {\n            this.lumpCategorize(obj);\n        }\n    }\n\n    private groupCategorize(obj: ContainerReflection) {\n        if (!obj.groups || obj.groups.length === 0) {\n            return;\n        }\n        obj.groups.forEach((group) => {\n            if (group.categories) return;\n\n            group.categories = CategoryPlugin.getReflectionCategories(\n                group.children\n            );\n            if (group.categories && group.categories.length > 1) {\n                group.categories.sort(CategoryPlugin.sortCatCallback);\n            } else if (\n                group.categories.length === 1 &&\n                group.categories[0].title === CategoryPlugin.defaultCategory\n            ) {\n                // no categories if everything is uncategorized\n                group.categories = undefined;\n            }\n        });\n    }\n\n    private lumpCategorize(obj: ContainerReflection) {\n        if (!obj.children || obj.children.length === 0 || obj.categories) {\n            return;\n        }\n        obj.categories = CategoryPlugin.getReflectionCategories(obj.children);\n        if (obj.categories && obj.categories.length > 1) {\n            obj.categories.sort(CategoryPlugin.sortCatCallback);\n        } else if (\n            obj.categories.length === 1 &&\n            obj.categories[0].title === CategoryPlugin.defaultCategory\n        ) {\n            // no categories if everything is uncategorized\n            obj.categories = undefined;\n        }\n    }\n\n    /**\n     * Create a categorized representation of the given list of reflections.\n     *\n     * @param reflections  The reflections that should be categorized.\n     * @returns An array containing all children of the given reflection categorized\n     */\n    static getReflectionCategories(\n        reflections: Reflection[]\n    ): ReflectionCategory[] {\n        const categories: ReflectionCategory[] = [];\n        let defaultCat: ReflectionCategory | undefined;\n        reflections.forEach((child) => {\n            const childCategories = CategoryPlugin.getCategories(child);\n            if (childCategories.length === 0) {\n                if (!defaultCat) {\n                    defaultCat = categories.find(\n                        (category) =>\n                            category.title === CategoryPlugin.defaultCategory\n                    );\n                    if (!defaultCat) {\n                        defaultCat = new ReflectionCategory(\n                            CategoryPlugin.defaultCategory\n                        );\n                        categories.push(defaultCat);\n                    }\n                }\n                defaultCat.children.push(child);\n                return;\n            }\n            for (const childCat of childCategories) {\n                let category = categories.find((cat) => cat.title === childCat);\n                if (category) {\n                    category.children.push(child);\n                    continue;\n                }\n                category = new ReflectionCategory(childCat);\n                category.children.push(child);\n                categories.push(category);\n            }\n        });\n        return categories;\n    }\n\n    /**\n     * Return the category of a given reflection.\n     *\n     * @param reflection The reflection.\n     * @returns The category the reflection belongs to\n     */\n    static getCategories(reflection: Reflection): string[] {\n        function extractCategoryTag(comment: Comment): string[] {\n            const categories: string[] = [];\n            const tags = comment.tags;\n            const commentTags: CommentTag[] = [];\n            tags.forEach((tag) => {\n                if (tag.tagName !== \"category\") {\n                    commentTags.push(tag);\n                    return;\n                }\n                const text = tag.text.trim();\n                if (!text) {\n                    return;\n                }\n                categories.push(text);\n            });\n            comment.tags = commentTags;\n            return categories;\n        }\n\n        if (reflection.comment) {\n            return extractCategoryTag(reflection.comment);\n        } else if (\n            reflection instanceof DeclarationReflection &&\n            reflection.signatures\n        ) {\n            return reflection.signatures.reduce(\n                (categories: string[], signature) => {\n                    if (!signature.comment) {\n                        return categories;\n                    }\n                    return categories.concat(\n                        extractCategoryTag(signature.comment)\n                    );\n                },\n                []\n            );\n        }\n        return [];\n    }\n\n    /**\n     * Callback used to sort categories by name.\n     *\n     * @param a The left reflection to sort.\n     * @param b The right reflection to sort.\n     * @returns The sorting weight.\n     */\n    static sortCatCallback(\n        a: ReflectionCategory,\n        b: ReflectionCategory\n    ): number {\n        let aWeight = CategoryPlugin.WEIGHTS.indexOf(a.title);\n        let bWeight = CategoryPlugin.WEIGHTS.indexOf(b.title);\n        if (aWeight === -1 || bWeight === -1) {\n            let asteriskIndex = CategoryPlugin.WEIGHTS.indexOf(\"*\");\n            if (asteriskIndex === -1) {\n                asteriskIndex = CategoryPlugin.WEIGHTS.length;\n            }\n            if (aWeight === -1) {\n                aWeight = asteriskIndex;\n            }\n            if (bWeight === -1) {\n                bWeight = asteriskIndex;\n            }\n        }\n        if (aWeight === bWeight) {\n            return a.title > b.title ? 1 : -1;\n        }\n        return aWeight - bWeight;\n    }\n}\n"]}
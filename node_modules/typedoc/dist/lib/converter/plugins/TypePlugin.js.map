{"version":3,"file":"TypePlugin.js","sourceRoot":"","sources":["../../../../src/lib/converter/plugins/TypePlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    ReflectionKind,\n    DeclarationReflection,\n    DeclarationHierarchy,\n} from \"../../models/reflections/index\";\nimport { Type, ReferenceType } from \"../../models/types/index\";\nimport { Component, ConverterComponent } from \"../components\";\nimport { Converter } from \"../converter\";\nimport { Context } from \"../context\";\n\n/**\n * A handler that converts all instances of [[LateResolvingType]] to their renderable equivalents.\n */\n@Component({ name: \"type\" })\nexport class TypePlugin extends ConverterComponent {\n    reflections: DeclarationReflection[] = [];\n\n    /**\n     * Create a new TypeHandler instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [Converter.EVENT_RESOLVE]: this.onResolve,\n            [Converter.EVENT_RESOLVE_END]: this.onResolveEnd,\n        });\n    }\n\n    /**\n     * Triggered when the converter resolves a reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    private onResolve(context: Context, reflection: DeclarationReflection) {\n        if (reflection.kindOf(ReflectionKind.ClassOrInterface)) {\n            this.postpone(reflection);\n\n            walk(reflection.implementedTypes, (target) => {\n                this.postpone(target);\n                if (!target.implementedBy) {\n                    target.implementedBy = [];\n                }\n                target.implementedBy.push(\n                    new ReferenceType(\n                        reflection.name,\n                        reflection,\n                        context.project\n                    )\n                );\n            });\n\n            walk(reflection.extendedTypes, (target) => {\n                this.postpone(target);\n                if (!target.extendedBy) {\n                    target.extendedBy = [];\n                }\n                target.extendedBy.push(\n                    new ReferenceType(\n                        reflection.name,\n                        reflection,\n                        context.project\n                    )\n                );\n            });\n        }\n\n        function walk(\n            types: Type[] | undefined,\n            callback: { (declaration: DeclarationReflection): void }\n        ) {\n            if (!types) {\n                return;\n            }\n            types.forEach((type) => {\n                if (!(type instanceof ReferenceType)) {\n                    return;\n                }\n                if (\n                    !type.reflection ||\n                    !(type.reflection instanceof DeclarationReflection)\n                ) {\n                    return;\n                }\n                callback(type.reflection);\n            });\n        }\n    }\n\n    private postpone(reflection: DeclarationReflection) {\n        if (!this.reflections.includes(reflection)) {\n            this.reflections.push(reflection);\n        }\n    }\n\n    /**\n     * Triggered when the converter has finished resolving a project.\n     */\n    private onResolveEnd(context: Context) {\n        this.reflections.forEach((reflection) => {\n            if (reflection.implementedBy) {\n                reflection.implementedBy.sort((a: any, b: any) => {\n                    if (a[\"name\"] === b[\"name\"]) {\n                        return 0;\n                    }\n                    return a[\"name\"] > b[\"name\"] ? 1 : -1;\n                });\n            }\n\n            let root!: DeclarationHierarchy;\n            let hierarchy!: DeclarationHierarchy;\n            function push(types: Type[]) {\n                const level: DeclarationHierarchy = { types: types };\n                if (hierarchy) {\n                    hierarchy.next = level;\n                    hierarchy = level;\n                } else {\n                    root = hierarchy = level;\n                }\n            }\n\n            if (reflection.extendedTypes) {\n                push(reflection.extendedTypes);\n            }\n\n            push([\n                new ReferenceType(reflection.name, reflection, context.project),\n            ]);\n            hierarchy.isTarget = true;\n\n            if (reflection.extendedBy) {\n                push(reflection.extendedBy);\n            }\n\n            reflection.typeHierarchy = root;\n        });\n    }\n}\n"]}
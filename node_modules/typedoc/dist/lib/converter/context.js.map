{"version":3,"file":"context.js","sourceRoot":"","sources":["../../../src/lib/converter/context.ts"],"names":[],"mappings":"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","sourcesContent":["import { ok as assert } from \"assert\";\nimport * as ts from \"typescript\";\n\nimport {\n    Reflection,\n    ProjectReflection,\n    ContainerReflection,\n    DeclarationReflection,\n    ReflectionKind,\n    ReflectionFlag,\n} from \"../models/index\";\n\nimport type { Converter } from \"./converter\";\nimport { isNamedNode } from \"./utils/nodes\";\nimport { ConverterEvents } from \"./converter-events\";\nimport { resolveAliasedSymbol } from \"./utils/symbols\";\n\n/**\n * The context describes the current state the converter is in.\n * @internal\n */\nexport class Context {\n    /**\n     * The converter instance that has created the context.\n     */\n    readonly converter: Converter;\n\n    /**\n     * The TypeChecker instance returned by the TypeScript compiler.\n     */\n    get checker(): ts.TypeChecker {\n        return this.program.getTypeChecker();\n    }\n\n    /**\n     * The program currently being converted.\n     * Accessing this property will throw if a source file is not currently being converted.\n     */\n    get program(): ts.Program {\n        assert(\n            this._program,\n            \"Tried to access Context.program when not converting a source file\"\n        );\n        return this._program;\n    }\n    private _program?: ts.Program;\n\n    /**\n     * All programs being converted.\n     */\n    readonly programs: readonly ts.Program[];\n\n    /**\n     * The project that is currently processed.\n     */\n    readonly project: ProjectReflection;\n\n    /**\n     * The scope or parent reflection that is currently processed.\n     */\n    readonly scope: Reflection;\n\n    /** @internal */\n    isConvertingTypeNode(): boolean {\n        return this.convertingTypeNode;\n    }\n\n    /** @internal */\n    setConvertingTypeNode() {\n        this.convertingTypeNode = true;\n    }\n\n    private convertingTypeNode = false;\n\n    /**\n     * Create a new Context instance.\n     *\n     * @param converter  The converter instance that has created the context.\n     * @param entryPoints  A list of all entry points for this project.\n     * @param checker  The TypeChecker instance returned by the TypeScript compiler.\n     * @internal\n     */\n    constructor(\n        converter: Converter,\n        programs: readonly ts.Program[],\n        project: ProjectReflection,\n        scope: Context[\"scope\"] = project\n    ) {\n        this.converter = converter;\n        this.programs = programs;\n\n        this.project = project;\n        this.scope = scope;\n    }\n\n    /** @internal */\n    get logger() {\n        return this.converter.application.logger;\n    }\n\n    /**\n     * Return the compiler options.\n     */\n    getCompilerOptions(): ts.CompilerOptions {\n        return this.converter.application.options.getCompilerOptions();\n    }\n\n    /**\n     * Return the type declaration of the given node.\n     *\n     * @param node  The TypeScript node whose type should be resolved.\n     * @returns The type declaration of the given node.\n     */\n    getTypeAtLocation(node: ts.Node): ts.Type | undefined {\n        let nodeType: ts.Type | undefined;\n        try {\n            nodeType = this.checker.getTypeAtLocation(node);\n        } catch {\n            // ignore\n        }\n        if (!nodeType) {\n            if (node.symbol) {\n                nodeType = this.checker.getDeclaredTypeOfSymbol(node.symbol);\n            } else if (node.parent && node.parent.symbol) {\n                nodeType = this.checker.getDeclaredTypeOfSymbol(\n                    node.parent.symbol\n                );\n            } else if (\n                node.parent &&\n                node.parent.parent &&\n                node.parent.parent.symbol\n            ) {\n                nodeType = this.checker.getDeclaredTypeOfSymbol(\n                    node.parent.parent.symbol\n                );\n            }\n        }\n        return nodeType;\n    }\n\n    getSymbolAtLocation(node: ts.Node): ts.Symbol | undefined {\n        let symbol = this.checker.getSymbolAtLocation(node);\n        if (!symbol && isNamedNode(node)) {\n            symbol = this.checker.getSymbolAtLocation(node.name);\n        }\n        return symbol;\n    }\n\n    expectSymbolAtLocation(node: ts.Node): ts.Symbol {\n        const symbol = this.getSymbolAtLocation(node);\n        if (!symbol) {\n            const { line } = ts.getLineAndCharacterOfPosition(\n                node.getSourceFile(),\n                node.pos\n            );\n            throw new Error(\n                `Expected a symbol for node with kind ${\n                    ts.SyntaxKind[node.kind]\n                } at ${node.getSourceFile().fileName}:${line + 1}`\n            );\n        }\n        return symbol;\n    }\n\n    resolveAliasedSymbol(symbol: ts.Symbol): ts.Symbol {\n        return resolveAliasedSymbol(symbol, this.checker);\n    }\n\n    createDeclarationReflection(\n        kind: ReflectionKind,\n        symbol: ts.Symbol | undefined,\n        name = getHumanName(symbol?.name ?? \"unknown\")\n    ) {\n        const reflection = new DeclarationReflection(name, kind, this.scope);\n        this.addChild(reflection);\n        if (symbol && this.converter.isExternal(symbol)) {\n            reflection.setFlag(ReflectionFlag.External);\n        }\n        this.registerReflection(reflection, symbol);\n\n        this.converter.trigger(\n            ConverterEvents.CREATE_DECLARATION,\n            this,\n            reflection,\n            // FIXME this isn't good enough.\n            symbol && this.converter.getNodesForSymbol(symbol, kind)[0]\n        );\n\n        return reflection;\n    }\n\n    addChild(reflection: DeclarationReflection) {\n        if (this.scope instanceof ContainerReflection) {\n            this.scope.children ??= [];\n            this.scope.children.push(reflection);\n        }\n    }\n\n    shouldIgnore(symbol: ts.Symbol) {\n        return this.converter.shouldIgnore(symbol, this.checker);\n    }\n\n    /**\n     * Register a newly generated reflection. All created reflections should be\n     * passed to this method to ensure that the project helper functions work correctly.\n     *\n     * @param reflection  The reflection that should be registered.\n     * @param symbol  The symbol the given reflection was resolved from.\n     */\n    registerReflection(reflection: Reflection, symbol: ts.Symbol | undefined) {\n        this.project.registerReflection(reflection, symbol);\n    }\n\n    /**\n     * Trigger a node reflection event.\n     *\n     * All events are dispatched on the current converter instance.\n     *\n     * @param name  The name of the event that should be triggered.\n     * @param reflection  The triggering reflection.\n     * @param node  The triggering TypeScript node if available.\n     */\n    trigger(name: string, reflection: Reflection, node?: ts.Node) {\n        this.converter.trigger(name, this, reflection, node);\n    }\n\n    /** @internal */\n    setActiveProgram(program: ts.Program | undefined) {\n        this._program = program;\n    }\n\n    /**\n     * @param callback  The callback function that should be executed with the changed context.\n     */\n    public withScope(scope: Reflection): Context {\n        const context = new Context(\n            this.converter,\n            this.programs,\n            this.project,\n            scope\n        );\n        context.convertingTypeNode = this.convertingTypeNode;\n        context.setActiveProgram(this._program);\n        return context;\n    }\n}\n\nconst builtInSymbolRegExp = /^__@(\\w+)$/;\n\nfunction getHumanName(name: string) {\n    const match = builtInSymbolRegExp.exec(name);\n    if (match) {\n        return `[Symbol.${match[1]}]`;\n    }\n    return name;\n}\n"]}
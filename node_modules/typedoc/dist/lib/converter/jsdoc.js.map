{"version":3,"file":"jsdoc.js","sourceRoot":"","sources":["../../../src/lib/converter/jsdoc.ts"],"names":[],"mappings":";AAAA,8CAA8C;AAC9C,WAAW;AACX,YAAY;;;AAEZ,mCAA4B;AAC5B,iCAAiC;AACjC,sCAMmB;AACnB,0CAAyC;AAEzC,yDAAqD;AACrD,qDAG+B;AAE/B,SAAgB,iBAAiB,CAC7B,OAAgB,EAChB,MAAiB,EACjB,WAAiD,EACjD,YAAqB;;IAErB,IACI,WAAW,CAAC,cAAc;QAC1B,EAAE,CAAC,kBAAkB,CAAC,WAAW,CAAC,cAAc,CAAC,EACnD;QACE,qBAAqB,CAAC,OAAO,EAAE,WAAW,EAAE,MAAM,EAAE,YAAY,CAAC,CAAC;QAClE,OAAO;KACV;IAED,MAAM,UAAU,GAAG,OAAO,CAAC,2BAA2B,CAClD,uBAAc,CAAC,SAAS,EACxB,MAAM,EACN,YAAY,CACf,CAAC;IAEF,UAAU,CAAC,IAAI,GAAG,OAAO,CAAC,SAAS,CAAC,WAAW,CAC3C,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,QAC7B,WAAW,CAAC,cAAc,0CAAE,IAAI,CACnC,CAAC;IAEF,yBAAyB,CACrB,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,EAC7B,WAAW,CAAC,MAAM,CACrB,CAAC;AACN,CAAC;AA7BD,8CA6BC;AAED,SAAgB,oBAAoB,CAChC,OAAgB,EAChB,MAAiB,EACjB,WAAgC,EAChC,YAAqB;IAErB,MAAM,KAAK,GAAG,OAAO,CAAC,2BAA2B,CAC7C,uBAAc,CAAC,SAAS,EACxB,MAAM,EACN,YAAY,CACf,CAAC;IACF,MAAM,EAAE,GAAG,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IAEpC,KAAK,CAAC,IAAI,GAAG,qBAAqB,CAAC,EAAE,EAAE,WAAW,CAAC,cAAc,CAAC,CAAC;IACnE,yBAAyB,CAAC,EAAE,EAAE,WAAW,CAAC,MAAM,CAAC,CAAC;AACtD,CAAC;AAfD,oDAeC;AAED,SAAS,qBAAqB,CAC1B,OAAgB,EAChB,WAAiD,EACjD,MAAiB,EACjB,YAAqB;IAErB,MAAM,UAAU,GAAG,OAAO,CAAC,2BAA2B,CAClD,uBAAc,CAAC,SAAS,EACxB,MAAM,EACN,YAAY,CACf,CAAC;IACF,MAAM,EAAE,GAAG,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;IAEzC,MAAM,IAAI,GAAG,OAAO,CAAC,OAAO,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC;IAC7D,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,aAAa,EAAE,EAAE;QAClC,OAAO,CAAC,SAAS,CAAC,aAAa,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;KAC1C;IAED,yBAAyB,CAAC,EAAE,EAAE,WAAW,CAAC,MAAM,CAAC,CAAC;AACtD,CAAC;AAED,SAAS,qBAAqB,CAAC,OAAgB,EAAE,IAAuB;;IACpE,MAAM,MAAM,SAAG,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,mCAAI,IAAI,CAAC,MAAM,CAAC;IAChE,MAAM,IAAI,GAAG,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;IAC7C,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,EAAE;QAClB,OAAO,IAAI,sBAAa,CAAC,UAAU,CAAC,CAAC;KACxC;IAED,MAAM,UAAU,GAAG,IAAI,8BAAqB,CACxC,QAAQ,EACR,uBAAc,CAAC,WAAW,EAC1B,OAAO,CAAC,KAAK,CAChB,CAAC;IACF,OAAO,CAAC,kBAAkB,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;IAC/C,OAAO,CAAC,OAAO,CAAC,kCAAe,CAAC,kBAAkB,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;IAEtE,MAAM,SAAS,GAAG,IAAI,4BAAmB,CACrC,QAAQ,EACR,uBAAc,CAAC,aAAa,EAC5B,UAAU,CACb,CAAC;IACF,OAAO,CAAC,kBAAkB,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC;IAC9C,MAAM,YAAY,GAAG,OAAO,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;IAElD,UAAU,CAAC,UAAU,GAAG,CAAC,SAAS,CAAC,CAAC;IACpC,SAAS,CAAC,IAAI,GAAG,OAAO,CAAC,SAAS,CAAC,WAAW,CAC1C,YAAY,cACZ,IAAI,CAAC,IAAI,0CAAE,cAAc,0CAAE,IAAI,CAClC,CAAC;IACF,SAAS,CAAC,UAAU,GAAG,iCAAqB,CACxC,YAAY,EACZ,SAAS,EACT,IAAI,CAAC,UAAU,CAClB,CAAC;IACF,SAAS,CAAC,cAAc,GAAG,6BAA6B,CACpD,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,EAC7B,IAAI,CAAC,cAAc,CACtB,CAAC;IAEF,OAAO,IAAI,uBAAc,CAAC,UAAU,CAAC,CAAC;AAC1C,CAAC;AAED,SAAS,yBAAyB,CAAC,OAAgB,EAAE,IAAc;;IAC/D,WAAE,CAAC,OAAO,CAAC,KAAK,YAAY,8BAAqB,CAAC,CAAC;IACnD,OAAO,CAAC,KAAK,CAAC,cAAc,GAAG,6BAA6B,CACxD,OAAO,QACP,IAAI,CAAC,IAAI,0CAAE,MAAM,CAAC,EAAE,CAAC,kBAAkB,EAC1C,CAAC;AACN,CAAC;AAED,SAAS,6BAA6B,CAClC,OAAgB,EAChB,KAAiD;IAEjD,MAAM,MAAM,GAAG,eAAO,CAAC,KAAK,aAAL,KAAK,cAAL,KAAK,GAAI,EAAE,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IACjE,OAAO,qCAAyB,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;AACtD,CAAC","sourcesContent":["// Converter functions for JSDoc defined types\n// @typedef\n// @callback\n\nimport { ok } from \"assert\";\nimport * as ts from \"typescript\";\nimport {\n    DeclarationReflection,\n    IntrinsicType,\n    ReflectionKind,\n    ReflectionType,\n    SignatureReflection,\n} from \"../models\";\nimport { flatMap } from \"../utils/array\";\nimport { Context } from \"./context\";\nimport { ConverterEvents } from \"./converter-events\";\nimport {\n    convertParameterNodes,\n    convertTypeParameterNodes,\n} from \"./factories/signature\";\n\nexport function convertJsDocAlias(\n    context: Context,\n    symbol: ts.Symbol,\n    declaration: ts.JSDocTypedefTag | ts.JSDocEnumTag,\n    nameOverride?: string\n) {\n    if (\n        declaration.typeExpression &&\n        ts.isJSDocTypeLiteral(declaration.typeExpression)\n    ) {\n        convertJsDocInterface(context, declaration, symbol, nameOverride);\n        return;\n    }\n\n    const reflection = context.createDeclarationReflection(\n        ReflectionKind.TypeAlias,\n        symbol,\n        nameOverride\n    );\n\n    reflection.type = context.converter.convertType(\n        context.withScope(reflection),\n        declaration.typeExpression?.type\n    );\n\n    convertTemplateParameters(\n        context.withScope(reflection),\n        declaration.parent\n    );\n}\n\nexport function convertJsDocCallback(\n    context: Context,\n    symbol: ts.Symbol,\n    declaration: ts.JSDocCallbackTag,\n    nameOverride?: string\n) {\n    const alias = context.createDeclarationReflection(\n        ReflectionKind.TypeAlias,\n        symbol,\n        nameOverride\n    );\n    const ac = context.withScope(alias);\n\n    alias.type = convertJsDocSignature(ac, declaration.typeExpression);\n    convertTemplateParameters(ac, declaration.parent);\n}\n\nfunction convertJsDocInterface(\n    context: Context,\n    declaration: ts.JSDocTypedefTag | ts.JSDocEnumTag,\n    symbol: ts.Symbol,\n    nameOverride?: string\n) {\n    const reflection = context.createDeclarationReflection(\n        ReflectionKind.Interface,\n        symbol,\n        nameOverride\n    );\n    const rc = context.withScope(reflection);\n\n    const type = context.checker.getDeclaredTypeOfSymbol(symbol);\n    for (const s of type.getProperties()) {\n        context.converter.convertSymbol(rc, s);\n    }\n\n    convertTemplateParameters(rc, declaration.parent);\n}\n\nfunction convertJsDocSignature(context: Context, node: ts.JSDocSignature) {\n    const symbol = context.getSymbolAtLocation(node) ?? node.symbol;\n    const type = context.getTypeAtLocation(node);\n    if (!symbol || !type) {\n        return new IntrinsicType(\"Function\");\n    }\n\n    const reflection = new DeclarationReflection(\n        \"__type\",\n        ReflectionKind.TypeLiteral,\n        context.scope\n    );\n    context.registerReflection(reflection, symbol);\n    context.trigger(ConverterEvents.CREATE_DECLARATION, reflection, node);\n\n    const signature = new SignatureReflection(\n        \"__type\",\n        ReflectionKind.CallSignature,\n        reflection\n    );\n    context.registerReflection(signature, void 0);\n    const signatureCtx = context.withScope(signature);\n\n    reflection.signatures = [signature];\n    signature.type = context.converter.convertType(\n        signatureCtx,\n        node.type?.typeExpression?.type\n    );\n    signature.parameters = convertParameterNodes(\n        signatureCtx,\n        signature,\n        node.parameters\n    );\n    signature.typeParameters = convertTemplateParameterNodes(\n        context.withScope(reflection),\n        node.typeParameters\n    );\n\n    return new ReflectionType(reflection);\n}\n\nfunction convertTemplateParameters(context: Context, node: ts.JSDoc) {\n    ok(context.scope instanceof DeclarationReflection);\n    context.scope.typeParameters = convertTemplateParameterNodes(\n        context,\n        node.tags?.filter(ts.isJSDocTemplateTag)\n    );\n}\n\nfunction convertTemplateParameterNodes(\n    context: Context,\n    nodes: readonly ts.JSDocTemplateTag[] | undefined\n) {\n    const params = flatMap(nodes ?? [], (tag) => tag.typeParameters);\n    return convertTypeParameterNodes(context, params);\n}\n"]}
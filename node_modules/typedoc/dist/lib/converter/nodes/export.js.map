{"version":3,"file":"export.js","sourceRoot":"","sources":["../../../../src/lib/converter/nodes/export.ts"],"names":[],"mappings":";;;;;;;;AAAA,iCAAiC;AAEjC,8CAA4G;AAE5G,8CAAkE;AAClE,sDAAmE;AACnE,uCAA6C;AAG7C,IAAa,eAAe,GAA5B,MAAa,eAAgB,SAAQ,mCAA2C;IAAhF;;QAII,aAAQ,GAAoB;YACxB,EAAE,CAAC,UAAU,CAAC,gBAAgB;SACjC,CAAC;IAuCN,CAAC;IArCG,OAAO,CAAC,OAAgB,EAAE,IAAyB;QAC/C,IAAI,MAA6B,CAAC;QAGlC,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,WAAW,CAAC,KAAK,EAAE;YACpF,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SAC1D;aAAM;YACH,IAAI,IAAI,GAAG,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACtD,MAAM,GAAG,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC;SAC3C;QACD,IAAI,MAAM,IAAI,MAAM,CAAC,YAAY,EAAE;YAC/B,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;YAChC,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,WAAW,EAAE,EAAE;gBACxC,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE;oBACrB,OAAO;iBACV;gBAED,MAAM,UAAU,GAAG,OAAO,CAAC,oBAAoB,CAAC,OAAO,CAAC,OAAO,CAAC,qBAAqB,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC;gBAC3G,IAAI,IAAI,CAAC,cAAc,IAAI,UAAU,YAAY,6BAAqB,EAAE;oBACpE,UAAU,CAAC,OAAO,CAAC,sBAAc,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAC;iBAC7D;gBACD,IAAI,UAAU,EAAE;oBACZ,cAAc,CAAC,UAAU,CAAC,CAAC;iBAC9B;YACL,CAAC,CAAC,CAAC;SACN;QAED,SAAS,cAAc,CAAC,UAAsB;YAC1C,IAAI,UAAU,YAAY,6BAAqB,EAAE;gBAC7C,UAAU,CAAC,OAAO,CAAC,sBAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;aACrD;YAED,UAAU,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;QACxC,CAAC;QAED,OAAO,OAAO,CAAC,KAAK,CAAC;IACzB,CAAC;CACJ,CAAA;AA7CY,eAAe;IAD3B,sBAAS,CAAC,EAAC,IAAI,EAAE,aAAa,EAAC,CAAC;GACpB,eAAe,CA6C3B;AA7CY,0CAAe;AAgD5B,IAAa,0BAA0B,GAAvC,MAAa,0BAA2B,SAAQ,mCAA4C;IAA5F;;QACI,aAAQ,GAAG,CAAC,EAAE,CAAC,UAAU,CAAC,iBAAiB,CAAC,CAAC;IA6CjD,CAAC;IA3CG,OAAO,CAAC,OAAgB,EAAE,IAA0B;QAEhD,IAAI,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,sBAAc,CAAC,IAAI,EAAE;YACnE,OAAO;SACV;QAED,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;QAC5B,IAAI,CAAC,CAAC,KAAK,YAAY,2BAAmB,CAAC,EAAE;YACzC,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;SACxD;QAED,IAAI,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,YAAY,EAAE;YAC5E,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;;gBAC3C,MAAM,MAAM,GAAG,OAAO,CAAC,sBAAsB,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;gBAC9D,MAAM,MAAM,GAAG,OAAO,CAAC,oBAAoB,CAAC,OAAO,CAAC,sBAAsB,OAAC,SAAS,CAAC,YAAY,mCAAI,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;gBAGtH,IAAI,CAAC,IAAI,CAAC,eAAe,IAAI,CAAC,SAAS,CAAC,YAAY,EAAE;oBAClD,OAAO;iBACV;gBAED,qCAAyB,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;YACvD,CAAC,CAAC,CAAC;SACN;aAAM,IAAI,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,eAAe,EAAE;YACtF,MAAM,MAAM,GAAG,OAAO,CAAC,sBAAsB,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YACtE,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;gBACvB,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;aACtE;YACD,MAAM,MAAM,GAAG,OAAO,CAAC,oBAAoB,CAAC,OAAO,CAAC,sBAAsB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC;YAClG,qCAAyB,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;SAEtD;aAAM,IAAI,IAAI,CAAC,eAAe,EAAE;YAC7B,MAAM,gBAAgB,GAAG,OAAO,CAAC,sBAAsB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;YAC9E,KAAK,MAAM,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,kBAAkB,CAAC,gBAAgB,CAAC,EAAE;gBACvE,IAAI,MAAM,CAAC,IAAI,KAAK,SAAS,EAAE;oBAC3B,SAAS;iBACZ;gBACD,qCAAyB,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC,CAAC;aACpF;SACJ;QAED,OAAO,OAAO,CAAC,KAAK,CAAC;IACzB,CAAC;CACJ,CAAA;AA9CY,0BAA0B;IADtC,sBAAS,CAAC,EAAE,IAAI,EAAE,yBAAyB,EAAE,CAAC;GAClC,0BAA0B,CA8CtC;AA9CY,gEAA0B","sourcesContent":["import * as ts from 'typescript';\n\nimport { Reflection, ReflectionFlag, DeclarationReflection, ContainerReflection } from '../../models/index';\nimport { Context } from '../context';\nimport { Component, ConverterNodeComponent } from '../components';\nimport { createReferenceReflection } from '../factories/reference';\nimport { SourceFileMode } from '../../utils';\n\n@Component({name: 'node:export'})\nexport class ExportConverter extends ConverterNodeComponent<ts.ExportAssignment> {\n    /**\n     * List of supported TypeScript syntax kinds.\n     */\n    supports: ts.SyntaxKind[] = [\n        ts.SyntaxKind.ExportAssignment\n    ];\n\n    convert(context: Context, node: ts.ExportAssignment): Reflection {\n        let symbol: ts.Symbol | undefined;\n\n        // default export\n        if (node.symbol && (node.symbol.flags & ts.SymbolFlags.Alias) === ts.SymbolFlags.Alias) {\n            symbol = context.checker.getAliasedSymbol(node.symbol);\n        } else {\n            let type = context.getTypeAtLocation(node.expression);\n            symbol = type ? type.symbol : undefined;\n        }\n        if (symbol && symbol.declarations) {\n            const project = context.project;\n            symbol.declarations.forEach((declaration) => {\n                if (!declaration.symbol) {\n                    return;\n                }\n\n                const reflection = project.getReflectionFromFQN(context.checker.getFullyQualifiedName(declaration.symbol));\n                if (node.isExportEquals && reflection instanceof DeclarationReflection) {\n                    reflection.setFlag(ReflectionFlag.ExportAssignment, true);\n                }\n                if (reflection) {\n                    markAsExported(reflection);\n                }\n            });\n        }\n\n        function markAsExported(reflection: Reflection) {\n            if (reflection instanceof DeclarationReflection) {\n                reflection.setFlag(ReflectionFlag.Exported, true);\n            }\n\n            reflection.traverse(markAsExported);\n        }\n\n        return context.scope;\n    }\n}\n\n@Component({ name: 'node:export-declaration' })\nexport class ExportDeclarationConverter extends ConverterNodeComponent<ts.ExportDeclaration> {\n    supports = [ts.SyntaxKind.ExportDeclaration];\n\n    convert(context: Context, node: ts.ExportDeclaration): Reflection | undefined {\n        // It doesn't make sense to convert export declarations if we are pretending everything is global.\n        if (this.application.options.getValue('mode') === SourceFileMode.File) {\n            return;\n        }\n\n        const scope = context.scope;\n        if (!(scope instanceof ContainerReflection)) {\n            throw new Error('Expected to be within a container');\n        }\n\n        if (node.exportClause && node.exportClause.kind === ts.SyntaxKind.NamedExports) { // export { a, a as b }\n            node.exportClause.elements.forEach(specifier => {\n                const source = context.expectSymbolAtLocation(specifier.name);\n                const target = context.resolveAliasedSymbol(context.expectSymbolAtLocation(specifier.propertyName ?? specifier.name));\n                // If the original declaration is in this file, export {} was used with something\n                // defined in this file and we don't need to create a reference unless the name is different.\n                if (!node.moduleSpecifier && !specifier.propertyName) {\n                    return;\n                }\n\n                createReferenceReflection(context, source, target);\n            });\n        } else if (node.exportClause && node.exportClause.kind === ts.SyntaxKind.NamespaceExport) { // export * as ns\n            const source = context.expectSymbolAtLocation(node.exportClause.name);\n            if (!node.moduleSpecifier) {\n                throw new Error('Namespace export is missing a module specifier.');\n            }\n            const target = context.resolveAliasedSymbol(context.expectSymbolAtLocation(node.moduleSpecifier));\n            createReferenceReflection(context, source, target);\n\n        } else if (node.moduleSpecifier) { // export * from ...\n            const sourceFileSymbol = context.expectSymbolAtLocation(node.moduleSpecifier);\n            for (const symbol of context.checker.getExportsOfModule(sourceFileSymbol)) {\n                if (symbol.name === 'default') { // Default exports are not re-exported with export *\n                    continue;\n                }\n                createReferenceReflection(context, symbol, context.resolveAliasedSymbol(symbol));\n            }\n        }\n\n        return context.scope;\n    }\n}\n"]}
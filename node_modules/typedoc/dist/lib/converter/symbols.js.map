{"version":3,"file":"symbols.js","sourceRoot":"","sources":["../../../src/lib/converter/symbols.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from \"assert\";\nimport * as ts from \"typescript\";\nimport {\n    DeclarationReflection,\n    ReferenceReflection,\n    Reflection,\n    ReflectionFlag,\n    ReflectionKind,\n    TypeParameterReflection,\n} from \"../models\";\nimport { flatMap, uniqueByEquals } from \"../utils/array\";\nimport {\n    getEnumFlags,\n    hasAllFlags,\n    hasAnyFlag,\n    removeFlag,\n} from \"../utils/enum\";\nimport { Context } from \"./context\";\nimport { convertDefaultValue } from \"./convert-expression\";\nimport { ConverterEvents } from \"./converter-events\";\nimport { convertIndexSignature } from \"./factories/index-signature\";\nimport { createSignature } from \"./factories/signature\";\nimport { convertJsDocAlias, convertJsDocCallback } from \"./jsdoc\";\n\nfunction getSymbolExportsWithFlag(symbol: ts.Symbol, flag: ts.SymbolFlags) {\n    const childSymbols: ts.Symbol[] = [];\n\n    symbol.exports?.forEach((child) => {\n        if (child.flags & flag) {\n            childSymbols.push(child);\n        }\n    });\n\n    return childSymbols;\n}\n\nconst symbolConverters: {\n    [K in ts.SymbolFlags]?: (\n        context: Context,\n        symbol: ts.Symbol,\n        nameOverride?: string\n    ) => void;\n} = {\n    [ts.SymbolFlags.RegularEnum]: convertEnum,\n    [ts.SymbolFlags.ConstEnum]: convertEnum,\n    [ts.SymbolFlags.EnumMember]: convertEnumMember,\n    [ts.SymbolFlags.ValueModule]: convertNamespace,\n    [ts.SymbolFlags.NamespaceModule]: convertNamespace,\n    [ts.SymbolFlags.TypeAlias]: convertTypeAlias,\n    [ts.SymbolFlags.Function]: convertFunctionOrMethod,\n    [ts.SymbolFlags.Method]: convertFunctionOrMethod,\n    [ts.SymbolFlags.Interface]: convertClassOrInterface,\n    [ts.SymbolFlags.Property]: convertProperty,\n    [ts.SymbolFlags.Class]: convertClassOrInterface,\n    [ts.SymbolFlags.Constructor]: convertConstructor,\n    [ts.SymbolFlags.Alias]: convertAlias,\n    [ts.SymbolFlags.BlockScopedVariable]: convertVariable,\n    [ts.SymbolFlags.FunctionScopedVariable]: convertVariable,\n    [ts.SymbolFlags.GetAccessor]: convertAccessor,\n    [ts.SymbolFlags.SetAccessor]: convertAccessor,\n};\n\n// Sanity check, if this fails a dev messed up.\nfor (const key of Object.keys(symbolConverters)) {\n    if (!Number.isInteger(Math.log2(+key))) {\n        throw new Error(\n            `Symbol converter for key ${\n                ts.SymbolFlags[+key]\n            } does not specify a valid flag value.`\n        );\n    }\n}\n\nexport function convertSymbol(\n    context: Context,\n    symbol: ts.Symbol,\n    nameOverride?: string\n): void {\n    if (context.shouldIgnore(symbol)) {\n        return;\n    }\n\n    let flags = removeFlag(\n        symbol.flags,\n        ts.SymbolFlags.Transient |\n            ts.SymbolFlags.Assignment |\n            ts.SymbolFlags.Optional |\n            ts.SymbolFlags.Prototype\n    );\n\n    // Declaration merging - the only type (excluding enum/enum, ns/ns, etc)\n    // that TD supports is merging a class and interface. All others are\n    // represented as multiple reflections\n    if (hasAllFlags(symbol.flags, ts.SymbolFlags.Class)) {\n        flags = removeFlag(\n            flags,\n            ts.SymbolFlags.Interface | ts.SymbolFlags.Function\n        );\n    }\n\n    // Kind of declaration merging... we treat this as a property with get/set signatures.\n    if (hasAllFlags(symbol.flags, ts.SymbolFlags.GetAccessor)) {\n        flags = removeFlag(flags, ts.SymbolFlags.SetAccessor);\n    }\n\n    if (hasAllFlags(symbol.flags, ts.SymbolFlags.NamespaceModule)) {\n        // This might be here if a namespace is declared several times.\n        flags = removeFlag(flags, ts.SymbolFlags.ValueModule);\n    }\n\n    if (hasAllFlags(symbol.flags, ts.SymbolFlags.Method)) {\n        // This happens when someone declares an object with methods:\n        // { methodProperty() {} }\n        flags = removeFlag(flags, ts.SymbolFlags.Property);\n    }\n\n    for (const flag of getEnumFlags(flags)) {\n        if (!(flag in symbolConverters)) {\n            context.logger.verbose(\n                `Missing converter for symbol: ${symbol.name} with flag ${ts.SymbolFlags[flag]}`\n            );\n        }\n        symbolConverters[flag]?.(context, symbol, nameOverride);\n    }\n}\n\nfunction convertSymbols(context: Context, symbols: readonly ts.Symbol[]) {\n    for (const symbol of symbols) {\n        convertSymbol(context, symbol);\n    }\n}\n\nfunction convertEnum(\n    context: Context,\n    symbol: ts.Symbol,\n    nameOverride?: string\n) {\n    const reflection = context.createDeclarationReflection(\n        ReflectionKind.Enum,\n        symbol,\n        nameOverride\n    );\n\n    if (symbol.flags & ts.SymbolFlags.ConstEnum) {\n        reflection.setFlag(ReflectionFlag.Const);\n    }\n\n    convertSymbols(\n        context.withScope(reflection),\n        getSymbolExportsWithFlag(symbol, ts.SymbolFlags.EnumMember)\n    );\n}\n\nfunction convertEnumMember(\n    context: Context,\n    symbol: ts.Symbol,\n    nameOverride?: string\n) {\n    const reflection = context.createDeclarationReflection(\n        ReflectionKind.EnumMember,\n        symbol,\n        nameOverride\n    );\n\n    reflection.defaultValue = JSON.stringify(\n        context.checker.getConstantValue(\n            symbol.getDeclarations()![0] as ts.EnumMember\n        )\n    );\n}\n\nfunction convertNamespace(\n    context: Context,\n    symbol: ts.Symbol,\n    nameOverride?: string\n) {\n    let exportFlags = ts.SymbolFlags.ModuleMember;\n\n    // This can happen in JS land where \"class\" functions get tagged as a namespace too\n    if (symbol.getDeclarations()?.some(ts.isModuleDeclaration) !== true) {\n        exportFlags = ts.SymbolFlags.ClassMember;\n\n        if (hasAnyFlag(symbol.flags, ts.SymbolFlags.Class)) {\n            return;\n        }\n    }\n\n    const reflection = context.createDeclarationReflection(\n        ReflectionKind.Namespace,\n        symbol,\n        nameOverride\n    );\n\n    convertSymbols(\n        context.withScope(reflection),\n        getSymbolExportsWithFlag(symbol, exportFlags)\n    );\n}\n\nfunction convertTypeAlias(\n    context: Context,\n    symbol: ts.Symbol,\n    nameOverride?: string\n) {\n    const declaration = symbol\n        ?.getDeclarations()\n        ?.find(\n            (\n                d\n            ): d is\n                | ts.TypeAliasDeclaration\n                | ts.JSDocTypedefTag\n                | ts.JSDocCallbackTag\n                | ts.JSDocEnumTag =>\n                ts.isTypeAliasDeclaration(d) ||\n                ts.isJSDocTypedefTag(d) ||\n                ts.isJSDocCallbackTag(d) ||\n                ts.isJSDocEnumTag(d)\n        );\n    assert(declaration);\n\n    if (ts.isTypeAliasDeclaration(declaration)) {\n        const reflection = context.createDeclarationReflection(\n            ReflectionKind.TypeAlias,\n            symbol,\n            nameOverride\n        );\n\n        reflection.type = context.converter.convertType(\n            context.withScope(reflection),\n            declaration.type\n        );\n\n        reflection.typeParameters = declaration.typeParameters?.map((param) =>\n            createTypeParamReflection(param, context.withScope(reflection))\n        );\n    } else if (\n        ts.isJSDocTypedefTag(declaration) ||\n        ts.isJSDocEnumTag(declaration)\n    ) {\n        convertJsDocAlias(context, symbol, declaration, nameOverride);\n    } else {\n        convertJsDocCallback(context, symbol, declaration, nameOverride);\n    }\n}\n\nfunction createTypeParamReflection(\n    param: ts.TypeParameterDeclaration,\n    context: Context\n) {\n    const constraint = param.constraint\n        ? context.converter.convertType(context, param.constraint)\n        : void 0;\n    const defaultType = param.default\n        ? context.converter.convertType(context, param.default)\n        : void 0;\n    const paramRefl = new TypeParameterReflection(\n        param.name.text,\n        constraint,\n        defaultType,\n        context.scope\n    );\n    context.registerReflection(paramRefl, undefined);\n    context.trigger(ConverterEvents.CREATE_TYPE_PARAMETER, paramRefl, param);\n    return paramRefl;\n}\n\nfunction convertFunctionOrMethod(\n    context: Context,\n    symbol: ts.Symbol,\n    nameOverride?: string\n) {\n    // Can't just check method flag because this might be called for properties as well\n    // This will *NOT* be called for variables that look like functions, they need a special case.\n    const isMethod = !!(\n        symbol.flags &\n        (ts.SymbolFlags.Property | ts.SymbolFlags.Method)\n    );\n\n    const declarations =\n        symbol.getDeclarations()?.filter(ts.isFunctionLike) ?? [];\n\n    // Don't do anything if we inherited this method and it is private.\n    if (\n        isMethod &&\n        isInherited(context, symbol) &&\n        declarations.length > 0 &&\n        hasAllFlags(\n            ts.getCombinedModifierFlags(declarations[0]),\n            ts.ModifierFlags.Private\n        )\n    ) {\n        return;\n    }\n\n    const parentSymbol = context.project.getSymbolFromReflection(context.scope);\n\n    const locationDeclaration =\n        parentSymbol\n            ?.getDeclarations()\n            ?.find(\n                (d) => ts.isClassDeclaration(d) || ts.isInterfaceDeclaration(d)\n            ) ??\n        parentSymbol?.getDeclarations()?.[0]?.getSourceFile() ??\n        symbol.getDeclarations()?.[0]?.getSourceFile();\n    assert(locationDeclaration, \"Missing declaration context\");\n\n    const type = context.checker.getTypeOfSymbolAtLocation(\n        symbol,\n        locationDeclaration\n    );\n    // Need to get the non nullable type because interface methods might be declared\n    // with a question token. See GH1490.\n    const signatures = type.getNonNullableType().getCallSignatures();\n\n    const reflection = context.createDeclarationReflection(\n        context.scope.kindOf(\n            ReflectionKind.ClassOrInterface |\n                ReflectionKind.VariableOrProperty |\n                ReflectionKind.TypeLiteral\n        )\n            ? ReflectionKind.Method\n            : ReflectionKind.Function,\n        symbol,\n        nameOverride\n    );\n\n    if (declarations.length && isMethod) {\n        // All method signatures must have the same modifier flags.\n        setModifiers(declarations[0], reflection);\n\n        assert(parentSymbol, \"Tried to convert a method without a parent.\");\n        if (\n            parentSymbol\n                .getDeclarations()\n                ?.some((d) => d === declarations[0].parent)\n        ) {\n            reflection.setOverwrites();\n        }\n    }\n\n    const scope = context.withScope(reflection);\n    reflection.signatures ??= [];\n\n    // Can't use zip here. We might have less declarations than signatures\n    // or less signatures than declarations.\n    for (let i = 0; i < signatures.length; i++) {\n        const converted = createSignature(\n            scope,\n            ReflectionKind.CallSignature,\n            signatures[i],\n            declarations[i]\n        );\n        reflection.signatures.push(converted);\n    }\n}\n\n// getDeclaredTypeOfSymbol gets the INSTANCE type\n// getTypeOfSymbolAtLocation gets the STATIC type\nfunction convertClassOrInterface(\n    context: Context,\n    symbol: ts.Symbol,\n    nameOverride?: string\n) {\n    const reflection = context.createDeclarationReflection(\n        ts.SymbolFlags.Class & symbol.flags\n            ? ReflectionKind.Class\n            : ReflectionKind.Interface,\n        symbol,\n        nameOverride\n    );\n    const reflectionContext = context.withScope(reflection);\n\n    const instanceType = context.checker.getDeclaredTypeOfSymbol(symbol);\n    assert(instanceType.isClassOrInterface());\n\n    const classDeclaration = symbol\n        .getDeclarations()\n        ?.find((d) => ts.isClassDeclaration(d) || ts.isFunctionDeclaration(d));\n    if (classDeclaration) {\n        setModifiers(classDeclaration, reflection);\n\n        // Classes can have static props\n        const staticType = context.checker.getTypeOfSymbolAtLocation(\n            symbol,\n            classDeclaration\n        );\n\n        for (const prop of context.checker.getPropertiesOfType(staticType)) {\n            // Don't convert namespace members, or the prototype here.\n            if (\n                prop.flags &\n                (ts.SymbolFlags.ModuleMember | ts.SymbolFlags.Prototype)\n            )\n                continue;\n            convertSymbol(reflectionContext, prop);\n\n            // We need to do this because of JS users. See GH1481\n            const refl = context.project.getReflectionFromSymbol(prop);\n            if (refl) {\n                refl.setFlag(ReflectionFlag.Static);\n            }\n        }\n\n        const constructMember = new DeclarationReflection(\n            \"constructor\",\n            ReflectionKind.Constructor,\n            reflection\n        );\n        reflectionContext.addChild(constructMember);\n        // The symbol is already taken by the class.\n        context.registerReflection(constructMember, undefined);\n\n        context.trigger(\n            ConverterEvents.CREATE_DECLARATION,\n            constructMember,\n            classDeclaration.getChildren().find(ts.isConstructorDeclaration)\n        );\n\n        const constructContext = reflectionContext.withScope(constructMember);\n\n        constructMember.signatures = staticType\n            .getConstructSignatures()\n            .map((sig, i) => {\n                // Modifiers are the same for all constructors\n                if (sig.declaration && i === 0) {\n                    setModifiers(sig.declaration, constructMember);\n                }\n                const sigRef = createSignature(\n                    constructContext,\n                    ReflectionKind.ConstructorSignature,\n                    sig\n                );\n                sigRef.name = `new ${reflectionContext.scope.name}`; // eww.. preserving legacy behavior.\n                sigRef.originalName = sigRef.name;\n                return sigRef;\n            });\n    }\n\n    // Classes/interfaces usually just have properties...\n    convertSymbols(\n        reflectionContext,\n        context.checker.getPropertiesOfType(instanceType)\n    );\n\n    // And type arguments\n    if (instanceType.typeParameters) {\n        reflection.typeParameters = instanceType.typeParameters.map((param) => {\n            const declaration = param.symbol?.declarations?.[0];\n            assert(ts.isTypeParameterDeclaration(declaration));\n            return createTypeParamReflection(declaration, reflectionContext);\n        });\n    }\n\n    // We also might do some inheritance\n    const declarations =\n        symbol\n            .getDeclarations()\n            ?.filter(\n                (d): d is ts.InterfaceDeclaration | ts.ClassDeclaration =>\n                    ts.isInterfaceDeclaration(d) || ts.isClassDeclaration(d)\n            ) ?? [];\n\n    const extendedTypes = flatMap(declarations, (decl) =>\n        flatMap(decl.heritageClauses ?? [], (clause) => {\n            if (clause.token !== ts.SyntaxKind.ExtendsKeyword) {\n                return [];\n            }\n            return clause.types.map((type) =>\n                context.converter.convertType(reflectionContext, type)\n            );\n        })\n    );\n    if (extendedTypes.length) {\n        reflection.extendedTypes = uniqueByEquals(extendedTypes);\n    }\n\n    const implementedTypes = flatMap(declarations, (decl) =>\n        flatMap(decl.heritageClauses ?? [], (clause) => {\n            if (clause.token !== ts.SyntaxKind.ImplementsKeyword) {\n                return [];\n            }\n            return clause.types.map((type) =>\n                context.converter.convertType(reflectionContext, type)\n            );\n        })\n    );\n    if (implementedTypes.length) {\n        reflection.implementedTypes = uniqueByEquals(implementedTypes);\n    }\n\n    // Interfaces might also have call signatures\n    // Classes might too, because of declaration merging\n    const callSignatures = context.checker\n        .getSignaturesOfType(instanceType, ts.SignatureKind.Call)\n        .map((sig) =>\n            createSignature(\n                reflectionContext,\n                ReflectionKind.CallSignature,\n                sig\n            )\n        );\n    if (callSignatures.length) {\n        reflection.signatures = callSignatures;\n    }\n\n    // We also might have constructor signatures\n    // This is potentially a problem with classes having\n    convertConstructSignatures(reflectionContext, symbol);\n\n    // And finally, index signatures\n    convertIndexSignature(reflectionContext, symbol);\n}\n\nfunction convertProperty(\n    context: Context,\n    symbol: ts.Symbol,\n    nameOverride?: string\n) {\n    const declarations = symbol.getDeclarations() ?? [];\n\n    // Don't do anything if we inherited this property and it is private.\n    if (\n        isInherited(context, symbol) &&\n        declarations.length > 0 &&\n        hasAllFlags(\n            ts.getCombinedModifierFlags(declarations[0]),\n            ts.ModifierFlags.Private\n        )\n    ) {\n        return;\n    }\n\n    // Special case: We pretend properties are methods if they look like methods.\n    // This happens with mixins / weird inheritance.\n    if (\n        declarations.every(\n            (decl) => ts.isMethodSignature(decl) || ts.isMethodDeclaration(decl)\n        )\n    ) {\n        return convertFunctionOrMethod(context, symbol, nameOverride);\n    }\n\n    // Special case: \"arrow methods\" should be treated as methods.\n    if (declarations.length === 1) {\n        const declaration = declarations[0];\n        if (\n            ts.isPropertyDeclaration(declaration) &&\n            !declaration.type &&\n            declaration.initializer &&\n            ts.isArrowFunction(declaration.initializer)\n        ) {\n            return convertArrowAsMethod(\n                context,\n                symbol,\n                declaration.initializer,\n                nameOverride\n            );\n        }\n    }\n\n    const reflection = context.createDeclarationReflection(\n        context.scope.kindOf(ReflectionKind.Namespace)\n            ? ReflectionKind.Variable\n            : ReflectionKind.Property,\n        symbol,\n        nameOverride\n    );\n\n    const declaration = symbol.getDeclarations()?.[0];\n    let parameterType: ts.TypeNode | undefined;\n\n    if (\n        declaration &&\n        (ts.isPropertyDeclaration(declaration) ||\n            ts.isPropertySignature(declaration) ||\n            ts.isParameter(declaration))\n    ) {\n        parameterType = declaration.type;\n        setModifiers(declaration, reflection);\n        const parentSymbol = context.project.getSymbolFromReflection(\n            context.scope\n        );\n        assert(parentSymbol, \"Tried to convert a property without a parent.\");\n        if (\n            parentSymbol\n                .getDeclarations()\n                ?.some((d) => d === declaration.parent)\n        ) {\n            reflection.setOverwrites();\n        }\n        if (ts.isPrivateIdentifier(declaration.name)) {\n            reflection.setFlag(ReflectionFlag.Private);\n        }\n    }\n    reflection.defaultValue = declaration && convertDefaultValue(declaration);\n\n    // FIXME: This is a horrible hack because getTypeOfSymbol is not exposed.\n    // The right solution here is probably to keep track of parent nodes...\n    // but that's tricky because not every reflection is guaranteed to have a\n    // parent node. This will probably break in a future TS version.\n    reflection.type = context.converter.convertType(\n        context,\n        (context.isConvertingTypeNode() ? parameterType : void 0) ??\n            context.checker.getTypeOfSymbolAtLocation(symbol, {} as any)\n    );\n}\n\nfunction convertArrowAsMethod(\n    context: Context,\n    symbol: ts.Symbol,\n    arrow: ts.ArrowFunction,\n    nameOverride?: string\n) {\n    const reflection = context.createDeclarationReflection(\n        ReflectionKind.Method,\n        symbol,\n        nameOverride\n    );\n    setModifiers(arrow.parent as ts.PropertyDeclaration, reflection);\n    const rc = context.withScope(reflection);\n\n    const signature = context.checker.getSignatureFromDeclaration(arrow);\n    assert(signature);\n\n    const parentSymbol = context.project.getSymbolFromReflection(context.scope);\n    assert(parentSymbol, \"Tried to convert an arrow method without a parent.\");\n    if (parentSymbol.getDeclarations()?.some((d) => d === arrow.parent)) {\n        reflection.setOverwrites();\n    }\n\n    reflection.signatures = [\n        createSignature(rc, ReflectionKind.CallSignature, signature, arrow),\n    ];\n}\n\nfunction convertConstructor(context: Context, symbol: ts.Symbol) {\n    const reflection = context.createDeclarationReflection(\n        ReflectionKind.Constructor,\n        symbol,\n        \"constructor\"\n    );\n    const reflectionContext = context.withScope(reflection);\n\n    const declarations =\n        symbol.getDeclarations()?.filter(ts.isConstructorDeclaration) ?? [];\n    const signatures = declarations.map((decl) => {\n        const sig = context.checker.getSignatureFromDeclaration(decl);\n        assert(sig);\n        return sig;\n    });\n\n    reflection.signatures = signatures.map((sig) => {\n        const sigRef = createSignature(\n            reflectionContext,\n            ReflectionKind.ConstructorSignature,\n            sig\n        );\n        sigRef.name = `new ${context.scope.name}`; // eww.. preserving legacy behavior.\n        sigRef.originalName = sigRef.name;\n        return sigRef;\n    });\n}\n\nfunction convertConstructSignatures(context: Context, symbol: ts.Symbol) {\n    const type = context.checker.getDeclaredTypeOfSymbol(symbol);\n\n    // These get added as a \"constructor\" member of this interface. This is a problem... but nobody\n    // has complained yet. We really ought to have a constructSignatures property on the reflection instead.\n    const constructSignatures = context.checker.getSignaturesOfType(\n        type,\n        ts.SignatureKind.Construct\n    );\n    if (constructSignatures.length) {\n        const constructMember = new DeclarationReflection(\n            \"constructor\",\n            ReflectionKind.Constructor,\n            context.scope\n        );\n        context.addChild(constructMember);\n        context.registerReflection(constructMember, undefined);\n\n        context.trigger(\n            ConverterEvents.CREATE_DECLARATION,\n            constructMember,\n            // FIXME this isn't good enough.\n            context.converter.getNodesForSymbol(\n                symbol,\n                ReflectionKind.Constructor\n            )[0]\n        );\n\n        const constructContext = context.withScope(constructMember);\n\n        constructMember.signatures = constructSignatures.map((sig) => {\n            const sigRef = createSignature(\n                constructContext,\n                ReflectionKind.ConstructorSignature,\n                sig\n            );\n            sigRef.name = `new ${context.scope.name}`; // eww.. preserving legacy behavior.\n            sigRef.originalName = sigRef.name;\n            return sigRef;\n        });\n    }\n}\n\nfunction convertAlias(\n    context: Context,\n    symbol: ts.Symbol,\n    nameOverride?: string\n) {\n    const reflection = context.project.getReflectionFromSymbol(\n        context.resolveAliasedSymbol(symbol)\n    );\n    if (!reflection) {\n        // We don't have this, convert it.\n        convertSymbol(\n            context,\n            context.resolveAliasedSymbol(symbol),\n            nameOverride ?? symbol.name\n        );\n    } else {\n        // We already have this. Create a reference.\n        const ref = new ReferenceReflection(\n            nameOverride ?? symbol.name,\n            reflection,\n            context.scope\n        );\n        context.addChild(ref);\n        context.registerReflection(ref, symbol);\n\n        context.trigger(\n            ConverterEvents.CREATE_DECLARATION,\n            reflection,\n            // FIXME this isn't good enough.\n            context.converter.getNodesForSymbol(\n                symbol,\n                ReflectionKind.Reference\n            )[0]\n        );\n    }\n}\n\nfunction convertVariable(\n    context: Context,\n    symbol: ts.Symbol,\n    nameOverride?: string\n) {\n    const declaration = symbol.getDeclarations()?.[0];\n    assert(declaration);\n\n    const type = context.checker.getTypeOfSymbolAtLocation(symbol, declaration);\n\n    if (type.getCallSignatures().length && !type.getProperties().length) {\n        return convertVariableAsFunction(context, symbol, nameOverride);\n    }\n\n    const reflection = context.createDeclarationReflection(\n        ReflectionKind.Variable,\n        symbol,\n        nameOverride\n    );\n\n    let typeNode: ts.TypeNode | undefined;\n    if (ts.isVariableDeclaration(declaration)) {\n        // Otherwise we might have destructuring\n        typeNode = declaration.type;\n    }\n\n    reflection.type = context.converter.convertType(\n        context.withScope(reflection),\n        typeNode ?? type\n    );\n\n    setModifiers(declaration, reflection);\n\n    // Does anyone care about this? I doubt it...\n    if (\n        ts.isVariableDeclaration(declaration) &&\n        hasAllFlags(symbol.flags, ts.SymbolFlags.BlockScopedVariable)\n    ) {\n        reflection.setFlag(\n            ReflectionFlag.Const,\n            hasAllFlags(declaration.parent.flags, ts.NodeFlags.Const)\n        );\n    }\n\n    reflection.defaultValue = convertDefaultValue(declaration);\n}\n\nfunction convertVariableAsFunction(\n    context: Context,\n    symbol: ts.Symbol,\n    nameOverride?: string\n) {\n    const declaration = symbol\n        .getDeclarations()\n        ?.find(ts.isVariableDeclaration);\n\n    const type = context.checker.getTypeOfSymbolAtLocation(\n        symbol,\n        declaration ?? symbol.valueDeclaration\n    );\n\n    const reflection = context.createDeclarationReflection(\n        ReflectionKind.Function,\n        symbol,\n        nameOverride\n    );\n    setModifiers(declaration ?? symbol.valueDeclaration, reflection);\n    // Does anyone care about this? I doubt it...\n    if (\n        declaration &&\n        hasAllFlags(symbol.flags, ts.SymbolFlags.BlockScopedVariable)\n    ) {\n        reflection.setFlag(\n            ReflectionFlag.Const,\n            hasAllFlags(\n                (declaration || symbol.valueDeclaration).parent.flags,\n                ts.NodeFlags.Const\n            )\n        );\n    }\n\n    const reflectionContext = context.withScope(reflection);\n\n    reflection.signatures ??= [];\n    for (const signature of type.getCallSignatures()) {\n        reflection.signatures.push(\n            createSignature(\n                reflectionContext,\n                ReflectionKind.CallSignature,\n                signature,\n                void 0,\n                declaration\n            )\n        );\n    }\n}\n\nfunction convertAccessor(\n    context: Context,\n    symbol: ts.Symbol,\n    nameOverride?: string\n) {\n    const reflection = context.createDeclarationReflection(\n        ReflectionKind.Accessor,\n        symbol,\n        nameOverride\n    );\n    const rc = context.withScope(reflection);\n\n    const getDeclaration = symbol.getDeclarations()?.find(ts.isGetAccessor);\n    if (getDeclaration) {\n        const signature = context.checker.getSignatureFromDeclaration(\n            getDeclaration\n        );\n        if (signature) {\n            reflection.getSignature = createSignature(\n                rc,\n                ReflectionKind.GetSignature,\n                signature,\n                getDeclaration\n            );\n        }\n    }\n\n    const setDeclaration = symbol.getDeclarations()?.find(ts.isSetAccessor);\n    if (setDeclaration) {\n        const signature = context.checker.getSignatureFromDeclaration(\n            setDeclaration\n        );\n        if (signature) {\n            reflection.setSignature = createSignature(\n                rc,\n                ReflectionKind.SetSignature,\n                signature,\n                setDeclaration\n            );\n        }\n    }\n}\n\nfunction isInherited(context: Context, symbol: ts.Symbol) {\n    const parentSymbol = context.project.getSymbolFromReflection(context.scope);\n    assert(parentSymbol);\n    return (\n        parentSymbol\n            .getDeclarations()\n            ?.some((d) =>\n                symbol.getDeclarations()?.some((d2) => d2.parent === d)\n            ) === false\n    );\n}\n\nfunction setModifiers(declaration: ts.Declaration, reflection: Reflection) {\n    const modifiers = ts.getCombinedModifierFlags(declaration);\n    // Note: We only set this flag if the modifier is present because we allow\n    // fake \"private\" or \"protected\" members via @private and @protected\n    if (hasAllFlags(modifiers, ts.ModifierFlags.Private)) {\n        reflection.setFlag(ReflectionFlag.Private);\n    }\n    if (hasAllFlags(modifiers, ts.ModifierFlags.Protected)) {\n        reflection.setFlag(ReflectionFlag.Protected);\n    }\n    if (hasAllFlags(modifiers, ts.ModifierFlags.Public)) {\n        reflection.setFlag(ReflectionFlag.Public);\n    }\n    reflection.setFlag(\n        ReflectionFlag.Optional,\n        !!(declaration as any).questionToken\n    );\n    reflection.setFlag(\n        ReflectionFlag.Readonly,\n        hasAllFlags(modifiers, ts.ModifierFlags.Readonly)\n    );\n    reflection.setFlag(\n        ReflectionFlag.Abstract,\n        hasAllFlags(modifiers, ts.ModifierFlags.Abstract)\n    );\n    reflection.setFlag(\n        ReflectionFlag.Static,\n        hasAllFlags(modifiers, ts.ModifierFlags.Static)\n    );\n}\n"]}
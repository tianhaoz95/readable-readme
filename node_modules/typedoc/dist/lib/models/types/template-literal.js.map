{"version":3,"file":"template-literal.js","sourceRoot":"","sources":["../../../../src/lib/models/types/template-literal.ts"],"names":[],"mappings":";;;AAAA,yCAAkC;AAElC;;;;;GAKG;AACH,MAAa,mBAAoB,SAAQ,eAAI;IAMzC,YAAY,IAAY,EAAE,IAAsB;QAC5C,KAAK,EAAE,CAAC;QANH,SAAI,GAAG,kBAAkB,CAAC;QAO/B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IACrB,CAAC;IAED,KAAK;QACD,OAAO,IAAI,mBAAmB,CAC1B,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,IAAI,CAAC,CAAC,CACxD,CAAC;IACN,CAAC;IAED,MAAM,CAAC,KAAW;QACd,OAAO,CACH,KAAK,YAAY,mBAAmB;YACpC,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI;YACxB,IAAI,CAAC,IAAI,CAAC,MAAM,KAAK,KAAK,CAAC,IAAI,CAAC,MAAM;YACtC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;gBAChC,OAAO,CACH,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,KAAK,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAC7D,CAAC;YACN,CAAC,CAAC,CACL,CAAC;IACN,CAAC;IAED,QAAQ;QACJ,OAAO;YACH,GAAG;YACH,IAAI,CAAC,IAAI;YACT,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,EAAE;gBAC9B,OAAO,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,CAAC;YACpC,CAAC,CAAC;YACF,GAAG;SACN,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACf,CAAC;CACJ;AA1CD,kDA0CC","sourcesContent":["import { Type } from \"./abstract\";\n\n/**\n * TS 4.1 template literal types\n * ```ts\n * type Z = `${'a' | 'b'}${'a' | 'b'}`\n * ```\n */\nexport class TemplateLiteralType extends Type {\n    readonly type = \"template-literal\";\n\n    head: string;\n    tail: [Type, string][];\n\n    constructor(head: string, tail: [Type, string][]) {\n        super();\n        this.head = head;\n        this.tail = tail;\n    }\n\n    clone(): Type {\n        return new TemplateLiteralType(\n            this.head,\n            this.tail.map(([type, text]) => [type.clone(), text])\n        );\n    }\n\n    equals(other: Type): boolean {\n        return (\n            other instanceof TemplateLiteralType &&\n            this.head === other.head &&\n            this.tail.length === other.tail.length &&\n            this.tail.every(([type, text], i) => {\n                return (\n                    type.equals(other.tail[i][0]) && text === other.tail[i][1]\n                );\n            })\n        );\n    }\n\n    toString() {\n        return [\n            \"`\",\n            this.head,\n            ...this.tail.map(([type, text]) => {\n                return \"${\" + type + \"}\" + text;\n            }),\n            \"`\",\n        ].join(\"\");\n    }\n}\n"]}
{"version":3,"file":"reference.js","sourceRoot":"","sources":["../../../../src/lib/models/types/reference.ts"],"names":[],"mappings":";;;AAEA,sDAAqD;AACrD,yCAAkC;AAElC;;;;;;GAMG;AACH,MAAa,aAAc,SAAQ,eAAI;IAwCnC;;OAEG;IACH,YACI,IAAY,EACZ,MAAuC,EACvC,OAA0B;QAE1B,KAAK,EAAE,CAAC;QA/CZ;;WAEG;QACM,SAAI,GAAG,WAAW,CAAC;QA2B5B;;;WAGG;QACH,kBAAa,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC;QAclC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,OAAO,GAAG,MAAM,YAAY,qBAAU,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC;QACjE,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;IAC5B,CAAC;IAjCD;;OAEG;IACH,IAAI,UAAU;QACV,IAAI,OAAO,IAAI,CAAC,OAAO,KAAK,QAAQ,EAAE;YAClC,OAAO,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SACxD;QACD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,uBAAuB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACrE,IAAI,QAAQ;YAAE,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC,EAAE,CAAC;QACzC,OAAO,QAAQ,CAAC;IACpB,CAAC;IAyBD,0FAA0F;IAC1F,MAAM,CAAC,qBAAqB,CAAC,IAAY,EAAE,OAA0B;QACjE,OAAO,IAAI,aAAa,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;IAChD,CAAC;IAED;;;;OAIG;IACH,KAAK;QACD,MAAM,KAAK,GAAG,IAAI,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QACxE,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC;QACzC,OAAO,KAAK,CAAC;IACjB,CAAC;IAED;;;;;OAKG;IACH,MAAM,CAAC,KAAoB;QACvB,IAAI,KAAK,YAAY,aAAa,EAAE;YAChC,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,EAAE;gBACzB,OAAO,IAAI,CAAC,UAAU,KAAK,KAAK,CAAC,UAAU,CAAC;aAC/C;YACD,OAAO,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO,CAAC;SACzC;QACD,OAAO,KAAK,CAAC;IACjB,CAAC;IAED;;;OAGG;IACH,QAAQ;QACJ,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;QAChE,IAAI,QAAQ,GAAG,EAAE,CAAC;QAElB,IAAI,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;YACrD,QAAQ,IAAI,GAAG,CAAC;YAChB,QAAQ,IAAI,IAAI,CAAC,aAAa;iBACzB,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC;iBAC5B,IAAI,CAAC,IAAI,CAAC,CAAC;YAChB,QAAQ,IAAI,GAAG,CAAC;SACnB;QAED,OAAO,IAAI,GAAG,QAAQ,CAAC;IAC3B,CAAC;CACJ;AAxGD,sCAwGC","sourcesContent":["import type * as ts from \"typescript\";\nimport type { ProjectReflection } from \"../reflections\";\nimport { Reflection } from \"../reflections/abstract\";\nimport { Type } from \"./abstract\";\n\n/**\n * Represents a type that refers to another reflection like a class, interface or enum.\n *\n * ~~~\n * let value: MyClass;\n * ~~~\n */\nexport class ReferenceType extends Type {\n    /**\n     * The type name identifier.\n     */\n    readonly type = \"reference\";\n\n    /**\n     * The name of the referenced type.\n     *\n     * If the symbol cannot be found cause it's not part of the documentation this\n     * can be used to represent the type.\n     */\n    name: string;\n\n    /**\n     * The type arguments of this reference.\n     */\n    typeArguments?: Type[];\n\n    /**\n     * The resolved reflection.\n     */\n    get reflection() {\n        if (typeof this._target === \"number\") {\n            return this._project.getReflectionById(this._target);\n        }\n        const resolved = this._project.getReflectionFromSymbol(this._target);\n        if (resolved) this._target = resolved.id;\n        return resolved;\n    }\n\n    /**\n     * Horrible hacky solution to get around Handlebars messing with `this` in bad ways.\n     * Don't use this if possible, it will go away once we use something besides handlebars for themes.\n     */\n    getReflection = () => this.reflection;\n\n    private _target: ts.Symbol | number;\n    private _project: ProjectReflection;\n\n    /**\n     * Create a new instance of ReferenceType.\n     */\n    constructor(\n        name: string,\n        target: ts.Symbol | Reflection | number,\n        project: ProjectReflection\n    ) {\n        super();\n        this.name = name;\n        this._target = target instanceof Reflection ? target.id : target;\n        this._project = project;\n    }\n\n    /** @internal this is used for type parameters, which don't actually point to something */\n    static createBrokenReference(name: string, project: ProjectReflection) {\n        return new ReferenceType(name, -1, project);\n    }\n\n    /**\n     * Clone this type.\n     *\n     * @return A clone of this type.\n     */\n    clone(): Type {\n        const clone = new ReferenceType(this.name, this._target, this._project);\n        clone.typeArguments = this.typeArguments;\n        return clone;\n    }\n\n    /**\n     * Test whether this type equals the given type.\n     *\n     * @param other  The type that should be checked for equality.\n     * @returns TRUE if the given type equals this type, FALSE otherwise.\n     */\n    equals(other: ReferenceType): boolean {\n        if (other instanceof ReferenceType) {\n            if (this.reflection != null) {\n                return this.reflection === other.reflection;\n            }\n            return this._target === other._target;\n        }\n        return false;\n    }\n\n    /**\n     * Return a string representation of this type.\n     * @example EventEmitter<any>\n     */\n    toString() {\n        const name = this.reflection ? this.reflection.name : this.name;\n        let typeArgs = \"\";\n\n        if (this.typeArguments && this.typeArguments.length > 0) {\n            typeArgs += \"<\";\n            typeArgs += this.typeArguments\n                .map((arg) => arg.toString())\n                .join(\", \");\n            typeArgs += \">\";\n        }\n\n        return name + typeArgs;\n    }\n}\n"]}
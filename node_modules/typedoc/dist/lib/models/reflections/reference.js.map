{"version":3,"file":"reference.js","sourceRoot":"","sources":["../../../../src/lib/models/reflections/reference.ts"],"names":[],"mappings":";;;AACA,yCAAwD;AACxD,+CAAsD;AAGtD;;;;;;;;;;;;GAYG;AACH,MAAa,mBAAoB,SAAQ,mCAAqB;IAI1D;;;;;;;OAOG;IACH,YACI,IAAY,EACZ,KAAqC,EACrC,MAAmB;QAEnB,KAAK,CAAC,IAAI,EAAE,yBAAc,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;QAC9C,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;IACzB,CAAC;IAED;;OAEG;IACH,IAAI,WAAW;QACX,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;OAGG;IACH,sBAAsB;QAClB,IAAI,CAAC,cAAc,EAAE,CAAC;QACtB,IAAI,IAAI,CAAC,OAAO,YAAY,qBAAU,EAAE;YACpC,OAAO,IAAI,CAAC,OAAO,CAAC;SACvB;QACD,MAAM,MAAM,GAAG,IAAI,CAAC,QAAS,CAAC,uBAAuB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACpE,IAAI,MAAM;YAAE,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QAClC,OAAO,MAAM,CAAC;IAClB,CAAC;IAED;;;OAGG;IACH,0BAA0B;QACtB,IAAI,MAAM,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAC3C,OAAO,MAAM,YAAY,mBAAmB,EAAE;YAC1C,MAAM,GAAG,MAAM,CAAC,sBAAsB,EAAE,CAAC;SAC5C;QACD,OAAO,MAAM,CAAC;IAClB,CAAC;IAED;;;OAGG;IACH,mBAAmB;QACf,IAAI,CAAC,cAAc,EAAE,CAAC;QAEtB,MAAM,MAAM,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAC7C,IAAI,CAAC,MAAM,EAAE;YACT,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;SAChD;QACD,OAAO,MAAM,CAAC;IAClB,CAAC;IAED;;;OAGG;IACH,uBAAuB;QACnB,IAAI,MAAM,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;QACxC,OAAO,MAAM,YAAY,mBAAmB,EAAE;YAC1C,MAAM,GAAG,MAAM,CAAC,mBAAmB,EAAE,CAAC;SACzC;QACD,OAAO,MAAM,CAAC;IAClB,CAAC;IAEO,cAAc;QAClB,IAAI,IAAI,CAAC,QAAQ,EAAE;YACf,OAAO;SACV;QAED,IAAI,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC;QAC1B,OAAO,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE;YACpC,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC;SAC5B;QACD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QAExB,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAChB,MAAM,IAAI,KAAK,CACX,+DAA+D,CAClE,CAAC;SACL;IACL,CAAC;CACJ;AAjGD,kDAiGC","sourcesContent":["import type * as ts from \"typescript\";\nimport { Reflection, ReflectionKind } from \"./abstract\";\nimport { DeclarationReflection } from \"./declaration\";\nimport { ProjectReflection } from \"./project\";\n\n/**\n * Describes a reflection which does not exist at this location, but is referenced. Used for imported reflections.\n *\n * ```ts\n * // a.ts\n * export const a = 1;\n * // b.ts\n * import { a } from './a';\n * // Here to avoid extra work we create a reference to the original reflection in module a instead\n * // of copying the reflection.\n * export { a };\n * ```\n */\nexport class ReferenceReflection extends DeclarationReflection {\n    private _target: Reflection | ts.Symbol;\n    private _project?: ProjectReflection;\n\n    /**\n     * Creates a reference reflection. Should only be used within the factory function.\n     * @param name\n     * @param state\n     * @param parent\n     *\n     * @internal\n     */\n    constructor(\n        name: string,\n        state: ReferenceReflection[\"_target\"],\n        parent?: Reflection\n    ) {\n        super(name, ReflectionKind.Reference, parent);\n        this._target = state;\n    }\n\n    /**\n     * Helper to check if this reflection is a reference for themes.\n     */\n    get isReference() {\n        return true;\n    }\n\n    /**\n     * Tries to get the reflection that is referenced. This may be another reference reflection.\n     * To fully resolve any references, use [[tryGetTargetReflectionDeep]].\n     */\n    tryGetTargetReflection(): Reflection | undefined {\n        this._ensureProject();\n        if (this._target instanceof Reflection) {\n            return this._target;\n        }\n        const target = this._project!.getReflectionFromSymbol(this._target);\n        if (target) this._target = target;\n        return target;\n    }\n\n    /**\n     * Tries to get the reflection that is referenced, this will fully resolve references.\n     * To only resolve one reference, use [[tryGetTargetReflection]].\n     */\n    tryGetTargetReflectionDeep(): Reflection | undefined {\n        let result = this.tryGetTargetReflection();\n        while (result instanceof ReferenceReflection) {\n            result = result.tryGetTargetReflection();\n        }\n        return result;\n    }\n\n    /**\n     * Gets the reflection that is referenced. This may be another reference reflection.\n     * To fully resolve any references, use [[getTargetReflectionDeep]].\n     */\n    getTargetReflection(): Reflection {\n        this._ensureProject();\n\n        const target = this.tryGetTargetReflection();\n        if (!target) {\n            throw new Error(\"Reference was unresolved.\");\n        }\n        return target;\n    }\n\n    /**\n     * Gets the reflection that is referenced, this will fully resolve references.\n     * To only resolve one reference, use [[getTargetReflection]].\n     */\n    getTargetReflectionDeep(): Reflection {\n        let result = this.getTargetReflection();\n        while (result instanceof ReferenceReflection) {\n            result = result.getTargetReflection();\n        }\n        return result;\n    }\n\n    private _ensureProject() {\n        if (this._project) {\n            return;\n        }\n\n        let project = this.parent;\n        while (project && !project.isProject()) {\n            project = project.parent;\n        }\n        this._project = project;\n\n        if (!this._project) {\n            throw new Error(\n                \"Reference reflection has no project and is unable to resolve.\"\n            );\n        }\n    }\n}\n"]}
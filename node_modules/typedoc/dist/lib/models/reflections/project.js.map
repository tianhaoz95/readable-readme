{"version":3,"file":"project.js","sourceRoot":"","sources":["../../../../src/lib/models/reflections/project.ts"],"names":[],"mappings":"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","sourcesContent":["import { SourceFile, SourceDirectory } from '../sources/index';\nimport { Reflection, ReflectionKind, TraverseProperty } from './abstract';\nimport { ContainerReflection } from './container';\nimport { splitUnquotedString } from './utils';\nimport { ReferenceReflection } from './reference';\nimport { DeclarationReflection } from './declaration';\nimport { SignatureReflection } from './signature';\nimport { ParameterReflection } from './parameter';\nimport { IntrinsicType } from '../types';\nimport { TypeParameterReflection } from './type-parameter';\nimport { removeIfPresent } from '../../utils';\n\n/**\n * A reflection that represents the root of the project.\n *\n * The project reflection acts as a global index, one may receive all reflections\n * and source files of the processed project through this reflection.\n */\nexport class ProjectReflection extends ContainerReflection {\n    private reflectionToSymbolIdMap = new WeakMap<Reflection, number[]>();\n    // The inverse of reflectionToSymbolIdMap\n    private symbolIdToReflectionIdMap = new Map<number, number>();\n    // Used to resolve references.\n    private fqnToReflectionIdMap = new Map<string, number>();\n\n    // Maps a reflection ID to all references eventually referring to it.\n    private referenceGraph?: Map<number, number[]>;\n\n    /**\n     * A list of all reflections within the project.\n     * @deprecated use {@link getReflectionById}, this will eventually be removed.\n     *   To iterate over all reflections, prefer {@link getReflectionsByKind}.\n     */\n    reflections: {[id: number]: Reflection} = {};\n\n    /**\n     * The root directory of the project.\n     */\n    directory: SourceDirectory = new SourceDirectory();\n\n    /**\n     * A list of all source files within the project.\n     */\n    files: SourceFile[] = [];\n\n    /**\n     * The name of the project.\n     *\n     * The name can be passed as a command line argument or it is read from the package info.\n     * this.name is assigned in the Reflection class.\n     */\n    name!: string;\n\n    /**\n     * The contents of the readme.md file of the project when found.\n     */\n    readme?: string;\n\n    /**\n     * The parsed data of the package.json file of the project when found.\n     */\n    packageInfo: any;\n\n    /**\n     * Create a new ProjectReflection instance.\n     *\n     * @param name  The name of the project.\n     */\n    constructor(name: string) {\n        super(name, ReflectionKind.Global);\n    }\n\n    /**\n     * Return whether this reflection is the root / project reflection.\n     */\n    isProject(): this is ProjectReflection {\n        return true;\n    }\n\n    /**\n     * Return a list of all reflections in this project of a certain kind.\n     *\n     * @param kind  The desired kind of reflection.\n     * @returns     An array containing all reflections with the desired kind.\n     */\n    getReflectionsByKind(kind: ReflectionKind): Reflection[] {\n        return Object.values(this.reflections)\n            .filter(reflection => reflection.kindOf(kind));\n    }\n\n    /**\n     * Try to find a reflection by its name.\n     *\n     * @param names The name hierarchy to look for, if a string, the name will be split on \".\"\n     * @return The found reflection or undefined.\n     */\n    findReflectionByName(arg: string | string[]): Reflection | undefined {\n        const names: string[] = Array.isArray(arg) ? arg : splitUnquotedString(arg, '.');\n        const name = names.pop();\n\n        search: for (const key in this.reflections) {\n            const reflection = this.reflections[key];\n            if (reflection.name !== name) {\n                continue;\n            }\n\n            let depth = names.length - 1;\n            let target: Reflection | undefined = reflection;\n            while ((target = target.parent) && depth >= 0) {\n                if (target.name !== names[depth]) {\n                    continue search;\n                }\n                depth -= 1;\n            }\n\n            return reflection;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * When excludeNotExported is set, if a symbol is exported only under a different name\n     * there will be a reference which points to the symbol, but the symbol will not be converted\n     * and the rename will point to nothing. Warn the user if this happens.\n     */\n    getDanglingReferences() {\n        const dangling = new Set<string>();\n        for (const ref of Object.values(this.reflections)) {\n            if (ref instanceof ReferenceReflection) {\n                if (!ref.tryGetTargetReflection()) {\n                    dangling.add(ref.name);\n                }\n            }\n        }\n        return [...dangling];\n    }\n\n    /**\n     * Registers the given reflection so that it can be quickly looked up by helper methods.\n     * Should be called for *every* reflection added to the project.\n     */\n    registerReflection(reflection: Reflection, fqn?: string) {\n        this.referenceGraph = undefined;\n        this.reflections[reflection.id] = reflection;\n\n        if (fqn) {\n            if (!this.fqnToReflectionIdMap.has(fqn)) {\n                this.fqnToReflectionIdMap.set(fqn, reflection.id);\n            }\n        }\n    }\n\n    /**\n     * Removes a reflection from the documentation. Can be used by plugins to filter reflections\n     * out of the generated documentation. Has no effect if the reflection is not present in the\n     * project.\n     *\n     * Note: If `removeReferences` is set to true, only references which have been created\n     * will be removed. If a reference is later created pointing to the removed reflection,\n     * it will not be removed and will still produce a broken reference.\n     */\n    removeReflection(reflection: Reflection, removeReferences = false) {\n        if (removeReferences) {\n            for (const id of this.getReferenceGraph().get(reflection.id) ?? []) {\n                const ref = this.getReflectionById(id);\n                if (ref) {\n                    this.removeReflection(ref, true);\n                }\n            }\n            this.getReferenceGraph().delete(reflection.id);\n        }\n\n        reflection.traverse(child => this.removeReflection(child, removeReferences));\n\n        const parent = reflection.parent as DeclarationReflection;\n        parent?.traverse((child, property) => {\n            if (child !== reflection) {\n                return true; // Continue iteration\n            }\n\n            if (property === TraverseProperty.Children) {\n                removeIfPresent(parent.children, reflection as DeclarationReflection);\n            } else if (property === TraverseProperty.GetSignature) {\n                delete parent.getSignature;\n            } else if (property === TraverseProperty.IndexSignature) {\n                delete parent.indexSignature;\n            } else if (property === TraverseProperty.Parameters) {\n                removeIfPresent(\n                    (reflection.parent as SignatureReflection).parameters,\n                    reflection as ParameterReflection\n                );\n            } else if (property === TraverseProperty.SetSignature) {\n                delete parent.setSignature;\n            } else if (property === TraverseProperty.Signatures) {\n                removeIfPresent(parent.signatures, reflection as SignatureReflection);\n            } else if (property === TraverseProperty.TypeLiteral) {\n                parent.type = new IntrinsicType('Object');\n            } else if (property === TraverseProperty.TypeParameter) {\n                removeIfPresent(parent.typeParameters, reflection as TypeParameterReflection);\n            }\n\n            return false; // Stop iteration\n        });\n\n        const ids = this.reflectionToSymbolIdMap.get(reflection);\n        for (const id of ids ?? []) {\n            this.symbolIdToReflectionIdMap.delete(id);\n        }\n\n        delete this.reflections[reflection.id];\n    }\n\n    /**\n     * Gets the reflection registered for the given reflection ID, or undefined if it is not present\n     * in the project.\n     */\n    getReflectionById(id: number): Reflection | undefined {\n        return this.reflections[id];\n    }\n\n    /**\n     * Gets the reflection associated with the given symbol, if it exists.\n     * @param fqn the fully qualified name of a symbol.\n     */\n    getReflectionFromFQN(fqn: string) {\n        const id = this.fqnToReflectionIdMap.get(fqn);\n        if (typeof id === 'number') {\n            return this.getReflectionById(id);\n        }\n    }\n\n    private getReferenceGraph(): Map<number, number[]> {\n        if (!this.referenceGraph) {\n            this.referenceGraph = new Map();\n            for (const ref of Object.values(this.reflections)) {\n                if (ref instanceof ReferenceReflection) {\n                    const target = ref.tryGetTargetReflection();\n                    if (target) {\n                        const refs = this.referenceGraph.get(target.id) ?? [];\n                        refs.push(ref.id);\n                        this.referenceGraph.set(target.id, refs);\n                    }\n                }\n            }\n        }\n\n        return this.referenceGraph;\n    }\n}\n"]}
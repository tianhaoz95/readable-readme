{"version":3,"file":"project.js","sourceRoot":"","sources":["../../../../src/lib/models/reflections/project.ts"],"names":[],"mappings":"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","sourcesContent":["import { SourceFile, SourceDirectory } from \"../sources/index\";\nimport { Reflection, ReflectionKind, TraverseProperty } from \"./abstract\";\nimport { ContainerReflection } from \"./container\";\nimport { splitUnquotedString } from \"./utils\";\nimport { ReferenceReflection } from \"./reference\";\nimport { DeclarationReflection } from \"./declaration\";\nimport { SignatureReflection } from \"./signature\";\nimport { ParameterReflection } from \"./parameter\";\nimport { IntrinsicType } from \"../types\";\nimport { TypeParameterReflection } from \"./type-parameter\";\nimport { removeIfPresent } from \"../../utils\";\nimport type * as ts from \"typescript\";\n\n/**\n * A reflection that represents the root of the project.\n *\n * The project reflection acts as a global index, one may receive all reflections\n * and source files of the processed project through this reflection.\n */\nexport class ProjectReflection extends ContainerReflection {\n    // Used to resolve references.\n    private symbolToReflectionIdMap = new Map<ts.Symbol, number>();\n\n    private reflectionIdToSymbolMap = new Map<number, ts.Symbol>();\n\n    // Maps a reflection ID to all references eventually referring to it.\n    private referenceGraph?: Map<number, number[]>;\n\n    /**\n     * A list of all reflections within the project.\n     * @deprecated use {@link getReflectionById}, this will eventually be removed.\n     *   To iterate over all reflections, prefer {@link getReflectionsByKind}.\n     */\n    reflections: { [id: number]: Reflection } = {};\n\n    /**\n     * The root directory of the project.\n     */\n    directory: SourceDirectory = new SourceDirectory();\n\n    /**\n     * A list of all source files within the project.\n     */\n    files: SourceFile[] = [];\n\n    /**\n     * The name of the project.\n     *\n     * The name can be passed as a command line argument or it is read from the package info.\n     * this.name is assigned in the Reflection class.\n     */\n    name!: string;\n\n    /**\n     * The contents of the readme.md file of the project when found.\n     */\n    readme?: string;\n\n    /**\n     * The parsed data of the package.json file of the project when found.\n     */\n    packageInfo: any;\n\n    /**\n     * Create a new ProjectReflection instance.\n     *\n     * @param name  The name of the project.\n     */\n    constructor(name: string) {\n        super(name, ReflectionKind.Project);\n    }\n\n    /**\n     * Return whether this reflection is the root / project reflection.\n     */\n    isProject(): this is ProjectReflection {\n        return true;\n    }\n\n    /**\n     * Return a list of all reflections in this project of a certain kind.\n     *\n     * @param kind  The desired kind of reflection.\n     * @returns     An array containing all reflections with the desired kind.\n     */\n    getReflectionsByKind(kind: ReflectionKind): Reflection[] {\n        return Object.values(this.reflections).filter((reflection) =>\n            reflection.kindOf(kind)\n        );\n    }\n\n    /**\n     * Try to find a reflection by its name.\n     *\n     * @param names The name hierarchy to look for, if a string, the name will be split on \".\"\n     * @return The found reflection or undefined.\n     */\n    findReflectionByName(arg: string | string[]): Reflection | undefined {\n        const names: string[] = Array.isArray(arg)\n            ? arg\n            : splitUnquotedString(arg, \".\");\n        const name = names.pop();\n\n        search: for (const key in this.reflections) {\n            const reflection = this.reflections[key];\n            if (reflection.name !== name) {\n                continue;\n            }\n\n            let depth = names.length - 1;\n            let target: Reflection | undefined = reflection;\n            while ((target = target.parent) && depth >= 0) {\n                if (target.name !== names[depth]) {\n                    continue search;\n                }\n                depth -= 1;\n            }\n\n            return reflection;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * When excludeNotExported is set, if a symbol is exported only under a different name\n     * there will be a reference which points to the symbol, but the symbol will not be converted\n     * and the rename will point to nothing. Warn the user if this happens.\n     */\n    removeDanglingReferences() {\n        const dangling = new Set<ReferenceReflection>();\n        for (const ref of Object.values(this.reflections)) {\n            if (ref instanceof ReferenceReflection) {\n                if (!ref.tryGetTargetReflection()) {\n                    dangling.add(ref);\n                }\n            }\n        }\n        for (const refl of dangling) {\n            this.removeReflection(refl);\n        }\n    }\n\n    /**\n     * Registers the given reflection so that it can be quickly looked up by helper methods.\n     * Should be called for *every* reflection added to the project.\n     */\n    registerReflection(reflection: Reflection, symbol?: ts.Symbol) {\n        this.referenceGraph = undefined;\n        this.reflections[reflection.id] = reflection;\n\n        if (symbol) {\n            this.symbolToReflectionIdMap.set(\n                symbol,\n                this.symbolToReflectionIdMap.get(symbol) ?? reflection.id\n            );\n            this.reflectionIdToSymbolMap.set(reflection.id, symbol);\n        }\n    }\n\n    /**\n     * Removes a reflection from the documentation. Can be used by plugins to filter reflections\n     * out of the generated documentation. Has no effect if the reflection is not present in the\n     * project.\n     */\n    removeReflection(reflection: Reflection) {\n        // Remove references\n        for (const id of this.getReferenceGraph().get(reflection.id) ?? []) {\n            const ref = this.getReflectionById(id);\n            if (ref) {\n                this.removeReflection(ref);\n            }\n        }\n        this.getReferenceGraph().delete(reflection.id);\n\n        reflection.traverse((child) => this.removeReflection(child));\n\n        const parent = reflection.parent as DeclarationReflection;\n        parent?.traverse((child, property) => {\n            if (child !== reflection) {\n                return true; // Continue iteration\n            }\n\n            if (property === TraverseProperty.Children) {\n                removeIfPresent(\n                    parent.children,\n                    reflection as DeclarationReflection\n                );\n            } else if (property === TraverseProperty.GetSignature) {\n                delete parent.getSignature;\n            } else if (property === TraverseProperty.IndexSignature) {\n                delete parent.indexSignature;\n            } else if (property === TraverseProperty.Parameters) {\n                removeIfPresent(\n                    (reflection.parent as SignatureReflection).parameters,\n                    reflection as ParameterReflection\n                );\n            } else if (property === TraverseProperty.SetSignature) {\n                delete parent.setSignature;\n            } else if (property === TraverseProperty.Signatures) {\n                removeIfPresent(\n                    parent.signatures,\n                    reflection as SignatureReflection\n                );\n            } else if (property === TraverseProperty.TypeLiteral) {\n                parent.type = new IntrinsicType(\"Object\");\n            } else if (property === TraverseProperty.TypeParameter) {\n                removeIfPresent(\n                    parent.typeParameters,\n                    reflection as TypeParameterReflection\n                );\n            }\n\n            return false; // Stop iteration\n        });\n\n        const symbol = this.reflectionIdToSymbolMap.get(reflection.id);\n        if (symbol) {\n            this.symbolToReflectionIdMap.delete(symbol);\n        }\n\n        delete this.reflections[reflection.id];\n    }\n\n    /**\n     * Gets the reflection registered for the given reflection ID, or undefined if it is not present\n     * in the project.\n     */\n    getReflectionById(id: number): Reflection | undefined {\n        return this.reflections[id];\n    }\n\n    /**\n     * Gets the reflection associated with the given symbol, if it exists.\n     * @internal\n     */\n    getReflectionFromSymbol(symbol: ts.Symbol) {\n        const id = this.symbolToReflectionIdMap.get(symbol);\n        if (typeof id === \"number\") {\n            return this.getReflectionById(id);\n        }\n    }\n\n    /** @internal */\n    getSymbolFromReflection(reflection: Reflection) {\n        return this.reflectionIdToSymbolMap.get(reflection.id);\n    }\n\n    private getReferenceGraph(): Map<number, number[]> {\n        if (!this.referenceGraph) {\n            this.referenceGraph = new Map();\n            for (const ref of Object.values(this.reflections)) {\n                if (ref instanceof ReferenceReflection) {\n                    const target = ref.tryGetTargetReflection();\n                    if (target) {\n                        const refs = this.referenceGraph.get(target.id) ?? [];\n                        refs.push(ref.id);\n                        this.referenceGraph.set(target.id, refs);\n                    }\n                }\n            }\n        }\n\n        return this.referenceGraph;\n    }\n}\n"]}
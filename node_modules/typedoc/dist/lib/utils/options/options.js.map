{"version":3,"file":"options.js","sourceRoot":"","sources":["../../../../src/lib/utils/options/options.ts"],"names":[],"mappings":"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","sourcesContent":["import { isDeepStrictEqual } from \"util\";\nimport * as _ from \"lodash\";\nimport * as ts from \"typescript\";\n\nimport {\n    convert,\n    DeclarationOption,\n    KeyToDeclaration,\n    ParameterType,\n    TypeDocOptionMap,\n    TypeDocOptions,\n    TypeDocOptionValues,\n} from \"./declaration\";\nimport { Logger } from \"../loggers\";\nimport { insertPrioritySorted, unique } from \"../array\";\nimport { addTypeDocOptions } from \"./sources\";\nimport { Application } from \"../../..\";\nimport { NeverIfInternal } from \"..\";\n\n/**\n * Describes an option reader that discovers user configuration and converts it to the\n * TypeDoc format.\n */\nexport interface OptionsReader {\n    /**\n     * Readers will be processed according to their priority.\n     * A higher priority indicates that the reader should be called *later* so that\n     * it can override options set by lower priority readers.\n     *\n     * Note that to preserve expected behavior, the argv reader must have both the lowest\n     * priority so that it may set the location of config files used by other readers and\n     * the highest priority so that it can override settings from lower priority readers.\n     */\n    priority: number;\n\n    /**\n     * The name of this reader so that it may be removed by plugins without the plugin\n     * accessing the instance performing the read. Multiple readers may have the same\n     * name.\n     */\n    name: string;\n\n    /**\n     * Read options from the reader's source and place them in the options parameter.\n     * Options without a declared name may be treated as if they were declared with type\n     * [[ParameterType.Mixed]]. Options which have been declared must be converted to the\n     * correct type. As an alternative to doing this conversion in the reader,\n     * the reader may use [[Options.setValue]], which will correctly convert values.\n     * @param options\n     * @param compilerOptions\n     * @param container the options container that provides declarations\n     * @param logger\n     */\n    read(container: Options, logger: Logger): void;\n}\n\n/**\n * Maintains a collection of option declarations split into TypeDoc options\n * and TypeScript options. Ensures options are of the correct type for calling\n * code.\n *\n * ### Option Discovery\n *\n * Since plugins commonly add custom options, and TypeDoc does not permit options which have\n * not been declared to be set, options must be read twice. The first time options are read,\n * a noop logger is passed so that any errors are ignored. Then, after loading plugins, options\n * are read again, this time with the logger specified by the application.\n *\n * Options are read in a specific order.\n * 1. argv (0) - Must be read first since it should change the files read when\n *    passing --options or --tsconfig.\n * 2. typedoc-json (100) - Read next so that it can specify the tsconfig.json file to read.\n * 3. tsconfig-json (200) - Last config file reader, cannot specify the typedoc.json file to read.\n * 4. argv (300) - Read argv again since any options set there should override those set in config\n *    files.\n */\nexport class Options {\n    private _readers: OptionsReader[] = [];\n    private _declarations = new Map<string, Readonly<DeclarationOption>>();\n    private _values: Record<string, unknown> = {};\n    private _setOptions = new Set<string>();\n    private _compilerOptions: ts.CompilerOptions = {};\n    private _fileNames: readonly string[] = [];\n    private _projectReferences: readonly ts.ProjectReference[] = [];\n    private _logger: Logger;\n\n    constructor(logger: Logger) {\n        this._logger = logger;\n    }\n\n    /**\n     * Sets the logger used when an option declaration fails to be added.\n     * @param logger\n     */\n    setLogger(logger: Logger) {\n        this._logger = logger;\n    }\n\n    /**\n     * Adds the option declarations declared by the TypeDoc and all supported TypeScript declarations.\n     */\n    addDefaultDeclarations() {\n        addTypeDocOptions(this);\n    }\n\n    /**\n     * Resets the option bag to all default values.\n     */\n    reset() {\n        for (const declaration of this.getDeclarations()) {\n            this.setOptionValueToDefault(declaration);\n        }\n        this._setOptions.clear();\n        this._compilerOptions = {};\n        this._fileNames = [];\n    }\n\n    /**\n     * Adds an option reader that will be used to read configuration values\n     * from the command line, configuration files, or other locations.\n     * @param reader\n     */\n    addReader(reader: OptionsReader): void {\n        insertPrioritySorted(this._readers, reader);\n    }\n\n    /**\n     * Removes all readers of a given name.\n     * @param name\n     */\n    removeReaderByName(name: string): void {\n        this._readers = this._readers.filter((reader) => reader.name !== name);\n    }\n\n    read(logger: Logger) {\n        for (const reader of this._readers) {\n            reader.read(this, logger);\n        }\n    }\n\n    /**\n     * Adds an option declaration to the container with extra type checking to ensure that\n     * the runtime type is consistent with the declared type.\n     * @param declaration The option declaration that should be added.\n     */\n    addDeclaration<K extends keyof TypeDocOptions>(\n        declaration: { name: K } & KeyToDeclaration<K>\n    ): void;\n\n    /**\n     * Adds an option declaration to the container.\n     * @param declaration The option declaration that should be added.\n     */\n    addDeclaration(\n        declaration: NeverIfInternal<Readonly<DeclarationOption>>\n    ): void;\n    addDeclaration(declaration: Readonly<DeclarationOption>): void {\n        const decl = this.getDeclaration(declaration.name);\n        if (decl) {\n            this._logger.error(\n                `The option ${declaration.name} has already been registered`\n            );\n        } else {\n            this._declarations.set(declaration.name, declaration);\n        }\n\n        this.setOptionValueToDefault(declaration);\n    }\n\n    /**\n     * Adds the given declarations to the container\n     * @param declarations\n     *\n     * @privateRemarks\n     * This function explicitly provides a way out of the strict typing enforced\n     * by {@link addDeclaration}. It should only be used with careful validation\n     * of the declaration map. Internally, it is only used for adding TS options\n     */\n    addDeclarations(declarations: readonly DeclarationOption[]): void {\n        for (const decl of declarations) {\n            this.addDeclaration(decl as any);\n        }\n    }\n\n    /**\n     * Removes a declared option.\n     * WARNING: This is probably a bad idea. If you do this you will probably cause a crash\n     * when code assumes that an option that it declared still exists.\n     * @param name\n     */\n    removeDeclarationByName(name: string): void {\n        const declaration = this.getDeclaration(name);\n        if (declaration) {\n            this._declarations.delete(declaration.name);\n            delete this._values[declaration.name];\n        }\n    }\n\n    /**\n     * Gets a declaration by one of its names.\n     * @param name\n     */\n    getDeclaration(name: string): Readonly<DeclarationOption> | undefined {\n        return this._declarations.get(name);\n    }\n\n    /**\n     * Gets all declared options.\n     */\n    getDeclarations(): Readonly<DeclarationOption>[] {\n        return unique(this._declarations.values());\n    }\n\n    /**\n     * Checks if the given option's value is deeply strict equal to the default.\n     * @deprecated Will be removed in v0.21. Use `isSet` instead.\n     * @param name\n     */\n    isDefault(name: keyof TypeDocOptions): boolean;\n    isDefault(name: NeverIfInternal<string>): boolean;\n    isDefault(name: string): boolean {\n        // getValue will throw if the declaration does not exist.\n        return isDeepStrictEqual(\n            this.getValue(name as keyof TypeDocOptions),\n            this.getDefaultOptionValue(this.getDeclaration(name)!)\n        );\n    }\n\n    /**\n     * Checks if the given option's value is deeply strict equal to the default.\n     * @param name\n     */\n    isSet(name: keyof TypeDocOptions): boolean;\n    isSet(name: NeverIfInternal<string>): boolean;\n    isSet(name: string): boolean {\n        if (!this._declarations.has(name)) {\n            throw new Error(\"Tried to check if an undefined option was set\");\n        }\n        return this._setOptions.has(name);\n    }\n\n    /**\n     * Gets all of the TypeDoc option values defined in this option container.\n     */\n    getRawValues(): Partial<TypeDocOptions> {\n        return _.cloneDeep(this._values);\n    }\n\n    /**\n     * Gets a value for the given option key, throwing if the option has not been declared.\n     * @param name\n     */\n    getValue<K extends keyof TypeDocOptions>(name: K): TypeDocOptionValues[K];\n    getValue(name: NeverIfInternal<string>): unknown;\n    getValue(name: string): unknown {\n        const declaration = this.getDeclaration(name);\n        if (!declaration) {\n            throw new Error(`Unknown option '${name}'`);\n        }\n\n        return this._values[declaration.name];\n    }\n\n    /**\n     * Sets the given declared option. Throws if setting the option fails.\n     * @param name\n     * @param value\n     */\n    setValue<K extends keyof TypeDocOptions>(\n        name: K,\n        value: TypeDocOptions[K]\n    ): void;\n    setValue(\n        name: NeverIfInternal<string>,\n        value: NeverIfInternal<unknown>\n    ): void;\n    setValue(name: string, value: unknown): void {\n        const declaration = this.getDeclaration(name);\n        if (!declaration) {\n            throw new Error(\n                `Tried to set an option (${name}) that was not declared.`\n            );\n        }\n\n        const converted = convert(value, declaration);\n        this._values[declaration.name] = converted;\n        this._setOptions.add(name);\n    }\n\n    /**\n     * Gets the set compiler options.\n     */\n    getCompilerOptions(): ts.CompilerOptions {\n        return _.cloneDeep(this._compilerOptions);\n    }\n\n    /**\n     * Gets the file names discovered through reading a tsconfig file.\n     */\n    getFileNames(): readonly string[] {\n        return this._fileNames;\n    }\n\n    /**\n     * Gets the project references - used in solution style tsconfig setups.\n     */\n    getProjectReferences(): readonly ts.ProjectReference[] {\n        return this._projectReferences;\n    }\n\n    /**\n     * Sets the compiler options that will be used to get a TS program.\n     */\n    setCompilerOptions(\n        fileNames: readonly string[],\n        options: ts.CompilerOptions,\n        projectReferences: readonly ts.ProjectReference[] | undefined\n    ) {\n        // We do this here instead of in the tsconfig reader so that API consumers which\n        // supply a program to `Converter.convert` instead of letting TypeDoc create one\n        // can just set the compiler options, and not need to know about this mapping.\n        // It feels a bit like a hack... but it's better to have it here than to put it\n        // in Application or Converter.\n        if (options.stripInternal && !this.isSet(\"excludeInternal\")) {\n            this.setValue(\"excludeInternal\", true);\n        }\n        this._fileNames = fileNames;\n        this._compilerOptions = _.cloneDeep(options);\n        this._projectReferences = projectReferences ?? [];\n    }\n\n    /**\n     * Sets the value of a given option to its default value.\n     * @param declaration The option whose value should be reset.\n     */\n    private setOptionValueToDefault(\n        declaration: Readonly<DeclarationOption>\n    ): void {\n        this._values[declaration.name] = this.getDefaultOptionValue(\n            declaration\n        );\n    }\n\n    private getDefaultOptionValue(\n        declaration: Readonly<DeclarationOption>\n    ): unknown {\n        // No need to convert the defaultValue for a map type as it has to be of a specific type\n        // Also don't use convert for number options to allow every possible number as a default value.\n        if (\n            declaration.type === ParameterType.Map ||\n            declaration.type === ParameterType.Number\n        ) {\n            return declaration.defaultValue;\n        } else {\n            return convert(declaration.defaultValue, declaration);\n        }\n    }\n}\n\n/**\n * Binds an option to the given property. Does not register the option.\n *\n * @since v0.16.3\n */\nexport function BindOption<K extends keyof TypeDocOptionMap>(\n    name: K\n): <IK extends PropertyKey>(\n    target: ({ application: Application } | { options: Options }) &\n        { [K2 in IK]: TypeDocOptionValues[K] },\n    key: IK\n) => void;\n\n/**\n * Binds an option to the given property. Does not register the option.\n * @since v0.16.3\n *\n * @privateRemarks\n * This overload is intended for plugin use only with looser type checks. Do not use internally.\n */\nexport function BindOption(\n    name: NeverIfInternal<string>\n): (\n    target: { application: Application } | { options: Options },\n    key: PropertyKey\n) => void;\n\nexport function BindOption(name: string) {\n    return function (\n        target: { application: Application } | { options: Options },\n        key: PropertyKey\n    ) {\n        Object.defineProperty(target, key, {\n            get(this: { application: Application } | { options: Options }) {\n                if (\"options\" in this) {\n                    return this.options.getValue(name as keyof TypeDocOptions);\n                } else {\n                    return this.application.options.getValue(\n                        name as keyof TypeDocOptions\n                    );\n                }\n            },\n            enumerable: true,\n            configurable: true,\n        });\n    };\n}\n"]}
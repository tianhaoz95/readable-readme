{"version":3,"file":"options.js","sourceRoot":"","sources":["../../../../src/lib/utils/options/options.ts"],"names":[],"mappings":";;AAAA,4BAA4B;AAG5B,+CAAmK;AAEnK,oCAAgD;AAChD,uCAA4D;AAyE5D,MAAa,OAAO;IAOhB,YAAY,MAAc;QANlB,aAAQ,GAAoB,EAAE,CAAC;QAC/B,kBAAa,GAAG,IAAI,GAAG,EAAuC,CAAC;QAC/D,YAAO,GAA4B,EAAE,CAAC;QACtC,qBAAgB,GAAuB,EAAE,CAAC;QAI9C,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IAC1B,CAAC;IAMD,SAAS,CAAC,MAAc;QACpB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IAC1B,CAAC;IAKD,sBAAsB;QAClB,sBAAY,CAAC,IAAI,CAAC,CAAC;QACnB,2BAAiB,CAAC,IAAI,CAAC,CAAC;IAC5B,CAAC;IAKD,KAAK;QACD,KAAK,MAAM,WAAW,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,EAAE;YACnD,IAAI,CAAC,uBAAuB,CAAC,WAAW,CAAC,CAAC;SAC7C;QACD,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;IAC/B,CAAC;IAOD,SAAS,CAAC,MAAqB;QAC3B,4BAAoB,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;IAChD,CAAC;IAMD,kBAAkB,CAAC,IAAY;QAC3B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;IACzE,CAAC;IAED,IAAI,CAAC,MAAc;QACf,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;YAChC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;SAC7B;IACL,CAAC;IAeD,cAAc,CAAC,WAAwC;QACnD,MAAM,KAAK,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACjC,IAAI,WAAW,CAAC,KAAK,EAAE;YACnB,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;SACjC;QAED,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;YAEtB,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;YACvC,IAAI,IAAI,IAAI,IAAI,KAAK,WAAW,EAAE;gBAC9B,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,cAAc,IAAI,8BAA8B,CAAC,CAAC;aACxE;iBAAM;gBACH,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,EAAE,EAAE,WAAW,CAAC,CAAC;aAC3D;SACJ;QAED,IAAI,CAAC,uBAAuB,CAAC,WAAW,CAAC,CAAC;IAC9C,CAAC;IAWD,eAAe,CAAC,YAA0C;QACtD,KAAK,MAAM,IAAI,IAAI,YAAY,EAAE;YAC7B,IAAI,CAAC,cAAc,CAAC,IAAW,CAAC,CAAC;SACpC;IACL,CAAC;IAQD,uBAAuB,CAAC,IAAY;QAChC,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QAC9C,IAAI,WAAW,EAAE;YACb,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC;YAC1D,IAAI,WAAW,CAAC,KAAK,EAAE;gBACnB,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;aAC9D;YACD,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;SACzC;IACL,CAAC;IAMD,cAAc,CAAC,IAAY;QACvB,OAAO,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC;IACtD,CAAC;IAMD,sBAAsB,CAAC,KAAqB;QACxC,OAAO,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,CAAC;aACjD,MAAM,CAAC,WAAW,CAAC,EAAE,WAAC,OAAA,OAAC,WAAW,CAAC,KAAK,mCAAI,4BAAc,CAAC,OAAO,CAAC,KAAK,KAAK,CAAA,EAAA,CAAC,CAAC;IACxF,CAAC;IAQD,SAAS,CAAC,IAAY;QAElB,OAAO,IAAI,CAAC,QAAQ,CAAC,IAA4B,CAAC,KAAK,IAAI,CAAC,cAAc,CAAC,IAAI,CAAE,CAAC,YAAY,CAAC;IACnG,CAAC;IAKD,YAAY;QACR,OAAO,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IACrC,CAAC;IAQD,QAAQ,CAAC,IAAY;QACjB,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QAC9C,IAAI,CAAC,WAAW,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,mBAAmB,IAAI,GAAG,CAAC,CAAC;SAC/C;QAED,IAAI,WAAW,CAAC,KAAK,KAAK,4BAAc,CAAC,UAAU,EAAE;YACjD,MAAM,IAAI,KAAK,CAAC,6DAA6D,CAAC,CAAC;SAClF;QAED,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;IAC1C,CAAC;IAKD,kBAAkB;QACd,OAAO,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IAC9C,CAAC;IASD,QAAQ,CAAC,IAAY,EAAE,KAAc;QACjC,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QAC9C,IAAI,CAAC,WAAW,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,2BAA2B,IAAI,0BAA0B,CAAC,CAAC;SAC9E;QAED,MAAM,SAAS,GAAG,qBAAO,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;QAC9C,MAAM,GAAG,GAAG,WAAW,CAAC,KAAK,KAAK,4BAAc,CAAC,UAAU;YACvD,CAAC,CAAC,IAAI,CAAC,gBAAgB;YACvB,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC;QACnB,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC;IACtC,CAAC;IAOD,SAAS,CAAC,GAAkD;QACxD,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,8DAA8D,CAAC,CAAC;QAClF,KAAK,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;YAC7C,IAAI,CAAC,QAAQ,CAAC,IAA4B,EAAE,KAAK,CAAC,CAAC;SACtD;IACL,CAAC;IAMO,uBAAuB,CAAC,WAAwC;QACpE,IAAI,WAAW,CAAC,KAAK,KAAK,4BAAc,CAAC,UAAU,EAAE;YAEjD,IAAI,WAAW,CAAC,IAAI,KAAK,2BAAa,CAAC,GAAG,EAAE;gBACxC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC,YAAY,CAAC;aAC7D;iBAAM,IAAI,WAAW,CAAC,IAAI,KAAK,2BAAa,CAAC,MAAM,EAAE;gBAElD,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC,YAAY,IAAI,CAAC,CAAC;aAClE;iBAAM;gBACH,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,qBAAO,CAAC,WAAW,CAAC,YAAY,EAAE,WAAW,CAAC,CAAC;aACnF;SACJ;IACL,CAAC;CACJ;AA1OD,0BA0OC;AAuBD,SAAgB,UAAU,CAAC,IAAY;IACnC,OAAO,UAAS,MAA2D,EAAE,GAAgB;QACzF,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,GAAG,EAAE;YAC/B,GAAG;gBACC,IAAI,SAAS,IAAI,IAAI,EAAE;oBACnB,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,IAA4B,CAAC,CAAC;iBAC9D;qBAAM;oBACH,OAAO,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,QAAQ,CAAC,IAA4B,CAAC,CAAC;iBAC1E;YACL,CAAC;YACD,UAAU,EAAE,IAAI;YAChB,YAAY,EAAE,IAAI;SACrB,CAAC,CAAC;IACP,CAAC,CAAC;AACN,CAAC;AAdD,gCAcC","sourcesContent":["import * as _ from 'lodash';\nimport * as ts from 'typescript';\n\nimport { DeclarationOption, ParameterScope, ParameterType, convert, TypeDocOptions, KeyToDeclaration, TypeDocAndTSOptions, TypeDocOptionMap } from './declaration';\nimport { Logger } from '../loggers';\nimport { insertPrioritySorted } from '../array';\nimport { addTSOptions, addTypeDocOptions } from './sources';\nimport { Application } from '../../..';\nimport { NeverIfInternal } from '..';\n\n/**\n * Describes an option reader that discovers user configuration and converts it to the\n * TypeDoc format.\n */\nexport interface OptionsReader {\n    /**\n     * Readers will be processed according to their priority.\n     * A higher priority indicates that the reader should be called *later* so that\n     * it can override options set by lower priority readers.\n     *\n     * Note that to preserve expected behavior, the argv reader must have both the lowest\n     * priority so that it may set the location of config files used by other readers and\n     * the highest priority so that it can override settings from lower priority readers.\n     */\n    priority: number;\n\n    /**\n     * The name of this reader so that it may be removed by plugins without the plugin\n     * accessing the instance performing the read. Multiple readers may have the same\n     * name.\n     */\n    name: string;\n\n    /**\n     * Read options from the reader's source and place them in the options parameter.\n     * Options without a declared name may be treated as if they were declared with type\n     * [[ParameterType.Mixed]]. Options which have been declared must be converted to the\n     * correct type. As an alternative to doing this conversion in the reader,\n     * the reader may use [[Options.setValue]], which will correctly convert values.\n     * @param options\n     * @param compilerOptions\n     * @param container the options container that provides declarations\n     * @param logger\n     */\n    read(container: Options, logger: Logger): void;\n}\n\n/**\n * Maintains a collection of option declarations split into TypeDoc options\n * and TypeScript options. Ensures options are of the correct type for calling\n * code.\n *\n * ### Case Sensitivity\n * All option keys are case insensitive. The following lines will each get the same value.\n * ```ts\n * const x = options.getValue('name');\n * const y = options.getValue('NAME');\n * const z = options.tryGetValue('NaMe').unwrap();\n * ```\n *\n * **WARNING**: This case insensitivity is primarily intended to ease command line use and for\n * backward compatibility. It may change in a future release. Any code using TypeDoc options\n * programmatically should conform to the case indicated in the [[TypeDocOptions]] interface.\n *\n * ### Option Discovery\n *\n * Since plugins commonly add custom options, and TypeDoc does not permit options which have\n * not been declared to be set, options must be read twice. The first time options are read,\n * a noop logger is passed so that any errors are ignored. Then, after loading plugins, options\n * are read again, this time with the logger specified by the application.\n *\n * Options are read in a specific order.\n * 1. argv (0) - Must be read first since it should change the files read when\n *    passing --options or --tsconfig.\n * 2. typedoc-json (100) - Read next so that it can specify the tsconfig.json file to read.\n * 3. tsconfig-json (200) - Last config file reader, cannot specify the typedoc.json file to read.\n * 4. argv (300) - Read argv again since any options set there should override those set in config\n *    files.\n */\nexport class Options {\n    private _readers: OptionsReader[] = [];\n    private _declarations = new Map<string, Readonly<DeclarationOption>>();\n    private _values: Partial<TypeDocOptions> = {};\n    private _compilerOptions: ts.CompilerOptions = {};\n    private _logger: Logger;\n\n    constructor(logger: Logger) {\n        this._logger = logger;\n    }\n\n    /**\n     * Sets the logger used when an option declaration fails to be added.\n     * @param logger\n     */\n    setLogger(logger: Logger) {\n        this._logger = logger;\n    }\n\n    /**\n     * Adds the option declarations declared by the TypeDoc and all supported TypeScript declarations.\n     */\n    addDefaultDeclarations() {\n        addTSOptions(this);\n        addTypeDocOptions(this);\n    }\n\n    /**\n     * Resets the option bag to all default values.\n     */\n    reset() {\n        for (const declaration of this._declarations.values()) {\n            this.setOptionValueToDefault(declaration);\n        }\n        this._compilerOptions = {};\n    }\n\n    /**\n     * Adds an option reader that will be used to read configuration values\n     * from the command line, configuration files, or other locations.\n     * @param reader\n     */\n    addReader(reader: OptionsReader): void {\n        insertPrioritySorted(this._readers, reader);\n    }\n\n    /**\n     * Removes all readers of a given name.\n     * @param name\n     */\n    removeReaderByName(name: string): void {\n        this._readers = this._readers.filter(reader => reader.name !== name);\n    }\n\n    read(logger: Logger) {\n        for (const reader of this._readers) {\n            reader.read(this, logger);\n        }\n    }\n\n    /**\n     * Adds an option declaration to the container with extra type checking to ensure that\n     * the runtime type is consistent with the declared type.\n     * @param declaration\n     */\n    addDeclaration<K extends keyof TypeDocOptions>(declaration: { name: K } & KeyToDeclaration<K>): void;\n\n    /**\n     * Adds an option declaration to the container.\n     * @param declaration\n     */\n    addDeclaration(declaration: NeverIfInternal<Readonly<DeclarationOption>>): void;\n\n    addDeclaration(declaration: Readonly<DeclarationOption>): void {\n        const names = [declaration.name];\n        if (declaration.short) {\n            names.push(declaration.short);\n        }\n\n        for (const name of names) {\n            // Check for registering the same declaration twice, should not be an error.\n            const decl = this.getDeclaration(name);\n            if (decl && decl !== declaration) {\n                this._logger.error(`The option ${name} has already been registered`);\n            } else {\n                this._declarations.set(name.toLowerCase(), declaration);\n            }\n        }\n\n        this.setOptionValueToDefault(declaration);\n    }\n\n    /**\n     * Adds the given declarations to the container\n     * @param declarations\n     *\n     * @privateRemarks\n     * This function explicitly provides a way out of the strict typing enforced\n     * by {@link addDeclaration}. It should only be used with careful validation\n     * of the declaration map. Internally, it is only used for adding TS options\n     */\n    addDeclarations(declarations: readonly DeclarationOption[]): void {\n        for (const decl of declarations) {\n            this.addDeclaration(decl as any);\n        }\n    }\n\n    /**\n     * Removes a declared option.\n     * WARNING: This is probably a bad idea. If you do this you will probably cause a crash\n     * when code assumes that an option that it declared still exists.\n     * @param name\n     */\n    removeDeclarationByName(name: string): void {\n        const declaration = this.getDeclaration(name);\n        if (declaration) {\n            this._declarations.delete(declaration.name.toLowerCase());\n            if (declaration.short) {\n                this._declarations.delete(declaration.short.toLowerCase());\n            }\n            delete this._values[declaration.name];\n        }\n    }\n\n    /**\n     * Gets a declaration by either its name or short name.\n     * @param name\n     */\n    getDeclaration(name: string): Readonly<DeclarationOption> | undefined {\n        return this._declarations.get(name.toLowerCase());\n    }\n\n    /**\n     * Gets all declarations in the options with a given scope.\n     * @param scope\n     */\n    getDeclarationsByScope(scope: ParameterScope) {\n        return _.uniq(Array.from(this._declarations.values()))\n            .filter(declaration => (declaration.scope ?? ParameterScope.TypeDoc) === scope);\n    }\n\n    /**\n     * Checks if the given option has a set value or if the value is the default value.\n     * @param name\n     */\n    isDefault(name: keyof TypeDocOptions): boolean;\n    isDefault(name: NeverIfInternal<string>): boolean;\n    isDefault(name: string): boolean {\n        // getValue will throw if the declaration does not exist.\n        return this.getValue(name as keyof TypeDocOptions) === this.getDeclaration(name)!.defaultValue;\n    }\n\n    /**\n     * Gets all of the TypeDoc option values defined in this option container.\n     */\n    getRawValues(): Partial<TypeDocOptions> {\n        return _.cloneDeep(this._values);\n    }\n\n    /**\n     * Gets a value for the given option key, throwing if the option has not been declared.\n     * @param name\n     */\n    getValue<K extends keyof TypeDocOptions>(name: K): TypeDocOptions[K];\n    getValue(name: NeverIfInternal<string>): unknown;\n    getValue(name: string): unknown {\n        const declaration = this.getDeclaration(name);\n        if (!declaration) {\n            throw new Error(`Unknown option '${name}'`);\n        }\n\n        if (declaration.scope === ParameterScope.TypeScript) {\n            throw new Error('TypeScript options must be fetched with getCompilerOptions.');\n        }\n\n        return this._values[declaration.name];\n    }\n\n    /**\n     * Gets the set compiler options.\n     */\n    getCompilerOptions(): ts.CompilerOptions {\n        return _.cloneDeep(this._compilerOptions);\n    }\n\n    /**\n     * Sets the given declared option. Throws if setting the option fails.\n     * @param name\n     * @param value\n     */\n    setValue<K extends keyof TypeDocAndTSOptions>(name: K, value: TypeDocAndTSOptions[K]): void;\n    setValue(name: NeverIfInternal<string>, value: NeverIfInternal<unknown>): void;\n    setValue(name: string, value: unknown): void {\n        const declaration = this.getDeclaration(name);\n        if (!declaration) {\n            throw new Error(`Tried to set an option (${name}) that was not declared.`);\n        }\n\n        const converted = convert(value, declaration);\n        const bag = declaration.scope === ParameterScope.TypeScript\n            ? this._compilerOptions\n            : this._values;\n        bag[declaration.name] = converted;\n    }\n\n    /**\n     * Sets all the given option values, throws if any value fails to be set.\n     * @param obj\n     * @deprecated will be removed in 0.19. Use setValue in a loop instead.\n     */\n    setValues(obj: NeverIfInternal<Partial<TypeDocAndTSOptions>>): void {\n        this._logger.warn('Options.setValues is deprecated and will be removed in 0.19.');\n        for (const [name, value] of Object.entries(obj)) {\n            this.setValue(name as keyof TypeDocOptions, value);\n        }\n    }\n\n    /**\n     * Sets the value of a given option to its default value.\n     * @param declaration The option whose value should be reset.\n     */\n    private setOptionValueToDefault(declaration: Readonly<DeclarationOption>): void {\n        if (declaration.scope !== ParameterScope.TypeScript) {\n            // No need to convert the defaultValue for a map type as it has to be of a specific type\n            if (declaration.type === ParameterType.Map) {\n                this._values[declaration.name] = declaration.defaultValue;\n            } else if (declaration.type === ParameterType.Number) {\n                // Don't use convert for number options to allow every possible number as a default value\n                this._values[declaration.name] = declaration.defaultValue || 0;\n            } else {\n                this._values[declaration.name] = convert(declaration.defaultValue, declaration);\n            }\n        }\n    }\n}\n\n/**\n * Binds an option to the given property. Does not register the option.\n *\n * @since v0.16.3\n */\nexport function BindOption<K extends keyof TypeDocOptionMap>(name: K):\n    <IK extends PropertyKey>(\n        target: ({ application: Application } | { options: Options }) & { [K2 in IK]: TypeDocOptions[K] },\n        key: IK\n    ) => void;\n\n/**\n * Binds an option to the given property. Does not register the option.\n * @since v0.16.3\n *\n * @privateRemarks\n * This overload is intended for plugin use only with looser type checks. Do not use internally.\n */\nexport function BindOption(name: NeverIfInternal<string>):\n    (target: { application: Application } | { options: Options }, key: PropertyKey) => void;\n\nexport function BindOption(name: string) {\n    return function(target: { application: Application } | { options: Options }, key: PropertyKey) {\n        Object.defineProperty(target, key, {\n            get(this: { application: Application } | { options: Options }) {\n                if ('options' in this) {\n                    return this.options.getValue(name as keyof TypeDocOptions);\n                } else {\n                    return this.application.options.getValue(name as keyof TypeDocOptions);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n    };\n}\n"]}
{"version":3,"file":"options.js","sourceRoot":"","sources":["../../../../src/lib/utils/options/options.ts"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash';\nimport * as ts from 'typescript';\n\nimport { DeclarationOption, ParameterScope, convert, TypeDocOptions, KeyToDeclaration, TypeDocAndTSOptions, TypeDocOptionMap } from './declaration';\nimport { Logger } from '../loggers';\nimport { Result, Ok, Err } from '../result';\nimport { insertPrioritySorted } from '../array';\nimport { addTSOptions, addTypeDocOptions } from './sources';\nimport { Application } from '../../..';\n\n/**\n * Describes an option reader that discovers user configuration and converts it to the\n * TypeDoc format.\n */\nexport interface OptionsReader {\n    /**\n     * Readers will be processed according to their priority.\n     * A higher priority indicates that the reader should be called *later* so that\n     * it can override options set by lower priority readers.\n     *\n     * Note that to preserve expected behavior, the argv reader must have both the lowest\n     * priority so that it may set the location of config files used by other readers and\n     * the highest priority so that it can override settings from lower priority readers.\n     */\n    priority: number;\n\n    /**\n     * The name of this reader so that it may be removed by plugins without the plugin\n     * accessing the instance performing the read. Multiple readers may have the same\n     * name.\n     */\n    name: string;\n\n    /**\n     * Read options from the reader's source and place them in the options parameter.\n     * Options without a declared name may be treated as if they were declared with type\n     * [[ParameterType.Mixed]]. Options which have been declared must be converted to the\n     * correct type. As an alternative to doing this conversion in the reader,\n     * the reader may use [[Options.setValue]], which will correctly convert values.\n     * @param options\n     * @param compilerOptions\n     * @param container the options container that provides declarations\n     * @param logger\n     */\n    read(container: Options, logger: Logger): void;\n}\n\n/**\n * Maintains a collection of option declarations split into TypeDoc options\n * and TypeScript options. Ensures options are of the correct type for calling\n * code.\n *\n * ### Case Sensitivity\n * All option keys are case insensitive. The following lines will each get the same value.\n * ```ts\n * const x = options.getValue('name');\n * const y = options.getValue('NAME');\n * const z = options.tryGetValue('NaMe').unwrap();\n * ```\n *\n * **WARNING**: This case insensitivity is primarily intended to ease command line use and for\n * backward compatibility. It may change in a future release. Any code using TypeDoc options\n * programmatically should conform to the case indicated in the [[TypeDocOptions]] interface.\n *\n * ### Option Discovery\n *\n * Since plugins commonly add custom options, and TypeDoc does not permit options which have\n * not been declared to be set, options must be read twice. The first time options are read,\n * a noop logger is passed so that any errors are ignored. Then, after loading plugins, options\n * are read again, this time with the logger specified by the application.\n *\n * Options are read in a specific order.\n * 1. argv (0) - Must be read first since it should change the files read when\n *    passing --options or --tsconfig.\n * 2. typedoc-json (100) - Read next so that it can specify the tsconfig.json file to read.\n * 3. tsconfig-json (200) - Last config file reader, cannot specify the typedoc.json file to read.\n * 4. argv (300) - Read argv again since any options set there should override those set in config\n *    files.\n */\nexport class Options {\n    private _readers: OptionsReader[] = [];\n    private _declarations = new Map<string, Readonly<DeclarationOption>>();\n    private _values: Partial<TypeDocOptions> = {};\n    private _compilerOptions: ts.CompilerOptions = {};\n    private _logger: Logger;\n\n    constructor(logger: Logger) {\n        this._logger = logger;\n    }\n\n    /**\n     * Sets the logger used when an option declaration fails to be added.\n     * @param logger\n     */\n    setLogger(logger: Logger) {\n        this._logger = logger;\n    }\n\n    /**\n     * Adds the option declarations declared by the TypeDoc and all supported TypeScript declarations.\n     */\n    addDefaultDeclarations() {\n        addTSOptions(this);\n        addTypeDocOptions(this);\n    }\n\n    /**\n     * Resets the option bag to all default values.\n     */\n    reset() {\n        for (const declaration of this._declarations.values()) {\n            if (declaration.scope !== ParameterScope.TypeScript) {\n                this._values[declaration.name] = convert(declaration.defaultValue, declaration)\n                    .expect(`Failed to validate default value for ${declaration.name}`);\n            }\n        }\n        this._compilerOptions = {};\n    }\n\n    /**\n     * Adds an option reader that will be used to read configuration values\n     * from the command line, configuration files, or other locations.\n     * @param reader\n     */\n    addReader(reader: OptionsReader): void {\n        insertPrioritySorted(this._readers, reader);\n    }\n\n    /**\n     * Removes all readers of a given name.\n     * @param name\n     */\n    removeReaderByName(name: string): void {\n        this._readers = this._readers.filter(reader => reader.name !== name);\n    }\n\n    read(logger: Logger) {\n        for (const reader of this._readers) {\n            reader.read(this, logger);\n        }\n    }\n\n    /**\n     * Adds an option declaration to the container with extra type checking to ensure that\n     * the runtime type is consistent with the declared type.\n     * @param declaration\n     */\n    addDeclaration<K extends keyof TypeDocOptions>(declaration: { name: K } & KeyToDeclaration<K>): void;\n\n    /**\n     * Adds an option declaration to the container.\n     * @param declaration\n     */\n    addDeclaration(declaration: Readonly<DeclarationOption>): void;\n\n    addDeclaration(declaration: Readonly<DeclarationOption>): void {\n        const names = [declaration.name];\n        if (declaration.short) {\n            names.push(declaration.short);\n        }\n\n        for (const name of names) {\n            // Check for registering the same declaration twice, should not be an error.\n            const decl = this.getDeclaration(name);\n            if (decl && decl !== declaration) {\n                this._logger.error(`The option ${name} has already been registered`);\n            } else {\n                this._declarations.set(name.toLowerCase(), declaration);\n            }\n        }\n\n        if (declaration.scope !== ParameterScope.TypeScript) {\n            this._values[declaration.name] = convert(declaration.defaultValue, declaration)\n                .expect(`Failed to validate default value for ${declaration.name}`);\n        }\n    }\n\n    /**\n     * Adds the given declarations to the container\n     * @param declarations\n     */\n    addDeclarations(declarations: readonly DeclarationOption[]): void {\n        for (const decl of declarations) {\n            this.addDeclaration(decl);\n        }\n    }\n\n    /**\n     * Removes a declared option.\n     * WARNING: This is probably a bad idea. If you do this you will probably cause a crash\n     * when code assumes that an option that it declared still exists.\n     * @param name\n     */\n    removeDeclarationByName(name: string): void {\n        const declaration = this.getDeclaration(name);\n        if (declaration) {\n            this._declarations.delete(declaration.name.toLowerCase());\n            if (declaration.short) {\n                this._declarations.delete(declaration.short.toLowerCase());\n            }\n            delete this._values[declaration.name];\n        }\n    }\n\n    /**\n     * Gets a declaration by either its name or short name.\n     * @param name\n     */\n    getDeclaration(name: string): Readonly<DeclarationOption> | undefined {\n        return this._declarations.get(name.toLowerCase());\n    }\n\n    /**\n     * Gets all declarations in the options with a given scope.\n     * @param scope\n     */\n    getDeclarationsByScope(scope: ParameterScope) {\n        return _.uniq(Array.from(this._declarations.values()))\n            .filter(declaration => (declaration.scope ?? ParameterScope.TypeDoc) === scope);\n    }\n\n    /**\n     * Checks if the given option has a set value or if the value is the default value.\n     * @param name\n     */\n    isDefault(name: keyof TypeDocAndTSOptions): boolean;\n    isDefault(name: string): boolean;\n    isDefault(name: string): boolean {\n        // getValue will throw if the declaration does not exist.\n        return this.getValue(name) === this.getDeclaration(name)!.defaultValue;\n    }\n\n    /**\n     * Gets all of the TypeDoc option values defined in this option container.\n     */\n    getRawValues(): Partial<TypeDocOptions> {\n        return _.cloneDeep(this._values);\n    }\n\n    /**\n     * Gets a value for the given option key, throwing if the option has not been declared.\n     * @param name\n     */\n    getValue<K extends keyof TypeDocOptions>(name: K): TypeDocOptions[K];\n    getValue(name: string): unknown;\n    getValue(name: string): unknown {\n        return this.tryGetValue(name).match({\n            ok: v => v,\n            err(err) { throw err; }\n        });\n    }\n\n    /**\n     * Tries to get the given option key, returns an [[Ok]] result if the option has been\n     * declared with a TypeDoc scope, or an [[Err]] result otherwise.\n     * @param name\n     */\n    tryGetValue<K extends keyof TypeDocOptions>(name: K): Result<TypeDocOptions[K], Error>;\n    tryGetValue(name: string): Result<unknown, Error>;\n    tryGetValue(name: string): Result<unknown, Error> {\n        const declaration = this.getDeclaration(name);\n        if (!declaration) {\n            return Err(new Error(`Unknown option '${name}'`));\n        }\n\n        if (declaration.scope === ParameterScope.TypeScript) {\n            return Err(new Error('TypeScript options must be fetched with getCompilerOptions.'));\n        }\n\n        return Ok(this._values[declaration.name]);\n    }\n\n    /**\n     * Gets the set compiler options.\n     */\n    getCompilerOptions(): ts.CompilerOptions {\n        return _.cloneDeep(this._compilerOptions);\n    }\n\n    /**\n     * Sets the given declared option. Returns a result with the Err set if the option fails,\n     * otherwise Ok(void).\n     * @param name\n     * @param value\n     */\n    setValue<K extends keyof TypeDocAndTSOptions>(name: K, value: TypeDocAndTSOptions[K]): Result<void, Error>;\n    setValue(name: string, value: unknown): Result<void, Error>;\n    setValue(name: string, value: unknown): Result<void, Error> {\n        const declaration = this.getDeclaration(name);\n        if (!declaration) {\n            return Err(Error(`Tried to set an option (${name}) that was not declared.`));\n        }\n\n        return convert(value, declaration).match({\n            ok: value => {\n                const bag = declaration.scope === ParameterScope.TypeScript\n                    ? this._compilerOptions\n                    : this._values;\n                bag[declaration.name] = value;\n                return Ok(void 0);\n            },\n            err: err => Err(Error(err))\n        });\n    }\n\n    /**\n     * Sets all the given option values, returns a result with an array of errors for\n     * keys which failed to be set.\n     * @param obj\n     */\n    setValues(obj: Partial<TypeDocAndTSOptions>): Result<void, Error[]> {\n        const errors: Error[] = [];\n        for (const [name, value] of Object.entries(obj)) {\n            this.setValue(name, value).match({\n                ok() {},\n                err(error) {\n                    errors.push(error);\n                }\n            });\n        }\n        return errors.length ? Err(errors) : Ok(void 0);\n    }\n}\n\n/**\n * Binds an option to the given property. Does not register the option.\n *\n * @since v0.16.3\n */\nexport function BindOption<K extends keyof TypeDocOptionMap>(name: K):\n    <IK extends PropertyKey>(\n        target: ({ application: Application } | { options: Options }) & { [K2 in IK]: TypeDocOptions[K] },\n        key: IK\n    ) => void;\n\n/**\n * Binds an option to the given property. Does not register the option.\n * @since v0.16.3\n *\n * @privateRemarks\n * This overload is intended for plugin use only with looser type checks. Do not use internally.\n */\nexport function BindOption(name: string):\n    (target: { application: Application } | { options: Options }, key: PropertyKey) => void;\n\nexport function BindOption(name: string) {\n    return function(target: { application: Application } | { options: Options }, key: PropertyKey) {\n        Object.defineProperty(target, key, {\n            get(this: { application: Application } | { options: Options }) {\n                if ('options' in this) {\n                    return this.options.getValue(name);\n                } else {\n                    return this.application.options.getValue(name);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n    };\n}\n"]}
{"version":3,"file":"declaration.js","sourceRoot":"","sources":["../../../../src/lib/utils/options/declaration.ts"],"names":[],"mappings":"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","sourcesContent":["import { LogLevel } from \"../loggers\";\nimport { Theme as ShikiTheme } from \"shiki-themes\";\n\n/**\n * An interface describing all TypeDoc specific options. Generated from a\n * map which contains more information about each option for better types when\n * defining said options.\n */\nexport type TypeDocOptions = {\n    [K in keyof TypeDocOptionMap]: TypeDocOptionMap[K] extends Record<\n        string,\n        infer U\n    >\n        ? Exclude<U, string> | keyof TypeDocOptionMap[K]\n        : TypeDocOptionMap[K];\n};\n\n/**\n * Describes all TypeDoc specific options as returned by {@link Options.getValue}, this is\n * slightly more restrictive than the {@link TypeDocOptions} since it does not allow both\n * keys and values for mapped option types.\n */\nexport type TypeDocOptionValues = {\n    [K in keyof TypeDocOptionMap]: TypeDocOptionMap[K] extends Record<\n        string,\n        infer U\n    >\n        ? Exclude<U, string>\n        : TypeDocOptionMap[K];\n};\n\n/**\n * Describes all TypeDoc options. Used internally to provide better types when fetching options.\n * External consumers should likely use [[TypeDocOptions]] instead.\n */\nexport interface TypeDocOptionMap {\n    options: string;\n    tsconfig: string;\n\n    entryPoints: string[];\n    exclude: string[];\n    externalPattern: string[];\n    excludeExternals: boolean;\n    excludePrivate: boolean;\n    excludeProtected: boolean;\n    excludeNotDocumented: boolean;\n    excludeInternal: boolean;\n    disableSources: boolean;\n    includes: string;\n    media: string;\n\n    emit: boolean;\n    watch: boolean;\n    preserveWatchOutput: boolean;\n\n    out: string;\n    json: string;\n\n    theme: string;\n    name: string;\n    includeVersion: boolean;\n    excludeTags: string[];\n    readme: string;\n    defaultCategory: string;\n    categoryOrder: string[];\n    categorizeByGroup: boolean;\n    gitRevision: string;\n    gitRemote: string;\n    gaID: string;\n    gaSite: string;\n    hideGenerator: boolean;\n    toc: string[];\n    disableOutputCheck: boolean;\n\n    help: boolean;\n    version: boolean;\n    showConfig: boolean;\n    plugin: string[];\n    logger: unknown; // string | Function\n    logLevel: typeof LogLevel;\n    listInvalidSymbolLinks: boolean;\n    markedOptions: unknown;\n\n    highlightTheme: ShikiTheme;\n}\n\n/**\n * Converts a given TypeDoc option key to the type of the declaration expected.\n */\nexport type KeyToDeclaration<\n    K extends keyof TypeDocOptionMap\n> = TypeDocOptionMap[K] extends boolean\n    ? BooleanDeclarationOption\n    : TypeDocOptionMap[K] extends string\n    ? StringDeclarationOption\n    : TypeDocOptionMap[K] extends number\n    ? NumberDeclarationOption\n    : TypeDocOptionMap[K] extends string[]\n    ? ArrayDeclarationOption\n    : unknown extends TypeDocOptionMap[K]\n    ? MixedDeclarationOption\n    : TypeDocOptionMap[K] extends Record<string | number, infer U>\n    ? MapDeclarationOption<U>\n    : never;\n\nexport enum ParameterHint {\n    File,\n    Directory,\n}\n\nexport enum ParameterType {\n    String,\n    Number,\n    Boolean,\n    Map,\n    Mixed,\n    Array,\n}\n\nexport interface DeclarationOptionBase {\n    /**\n     * The option name.\n     */\n    name: string;\n\n    /**\n     * The help text to be displayed to the user when --help is passed.\n     */\n    help: string;\n\n    /**\n     * The parameter type, used to convert user configuration values into the expected type.\n     * If not set, the type will be a string.\n     */\n    type?: ParameterType;\n}\n\nexport interface StringDeclarationOption extends DeclarationOptionBase {\n    type?: ParameterType.String;\n\n    /**\n     * If not specified defaults to the empty string.\n     */\n    defaultValue?: string;\n\n    /**\n     * An optional hint for the type of input expected, will be displayed in the help output.\n     */\n    hint?: ParameterHint;\n\n    /**\n     * An optional validation function that validates a potential value of this option.\n     * The function must throw an Error if the validation fails and should do nothing otherwise.\n     */\n    validate?: (value: string) => void;\n}\n\nexport interface NumberDeclarationOption extends DeclarationOptionBase {\n    type: ParameterType.Number;\n\n    /**\n     * Lowest possible value.\n     */\n    minValue?: number;\n\n    /**\n     * Highest possible value.\n     */\n    maxValue?: number;\n\n    /**\n     * If not specified defaults to 0.\n     */\n    defaultValue?: number;\n\n    /**\n     * An optional validation function that validates a potential value of this option.\n     * The function must throw an Error if the validation fails and should do nothing otherwise.\n     */\n    validate?: (value: number) => void;\n}\n\nexport interface BooleanDeclarationOption extends DeclarationOptionBase {\n    type: ParameterType.Boolean;\n\n    /**\n     * If not specified defaults to false.\n     */\n    defaultValue?: boolean;\n}\n\nexport interface ArrayDeclarationOption extends DeclarationOptionBase {\n    type: ParameterType.Array;\n\n    /**\n     * If not specified defaults to an empty array.\n     */\n    defaultValue?: string[];\n\n    /**\n     * An optional validation function that validates a potential value of this option.\n     * The function must throw an Error if the validation fails and should do nothing otherwise.\n     */\n    validate?: (value: string[]) => void;\n}\n\nexport interface MixedDeclarationOption extends DeclarationOptionBase {\n    type: ParameterType.Mixed;\n\n    /**\n     * If not specified defaults to undefined.\n     */\n    defaultValue?: unknown;\n\n    /**\n     * An optional validation function that validates a potential value of this option.\n     * The function must throw an Error if the validation fails and should do nothing otherwise.\n     */\n    validate?: (value: unknown) => void;\n}\n\nexport interface MapDeclarationOption<T> extends DeclarationOptionBase {\n    type: ParameterType.Map;\n\n    /**\n     * Maps a given value to the option type. The map type may be a TypeScript enum.\n     * In that case, when generating an error message for a mismatched key, the numeric\n     * keys will not be listed.\n     */\n    map: Map<string, T> | Record<string | number, T>;\n\n    /**\n     * Unlike the rest of the option types, there is no sensible generic default for mapped option types.\n     * The default value for a mapped type must be specified.\n     */\n    defaultValue: T;\n\n    /**\n     * Optional override for the error reported when an invalid key is provided.\n     */\n    mapError?: string;\n}\n\nexport type DeclarationOption =\n    | StringDeclarationOption\n    | NumberDeclarationOption\n    | BooleanDeclarationOption\n    | MixedDeclarationOption\n    | MapDeclarationOption<unknown>\n    | ArrayDeclarationOption;\n\nexport type DeclarationOptionToOptionType<\n    T extends DeclarationOption\n> = T extends StringDeclarationOption\n    ? string\n    : T extends NumberDeclarationOption\n    ? number\n    : T extends BooleanDeclarationOption\n    ? boolean\n    : T extends MixedDeclarationOption\n    ? unknown\n    : T extends MapDeclarationOption<infer U>\n    ? U\n    : T extends ArrayDeclarationOption\n    ? string[]\n    : never;\n\n/**\n * The default conversion function used by the Options container. Readers may\n * re-use this conversion function or implement their own. The arguments reader\n * implements its own since 'false' should not be converted to true for a boolean option.\n * @param value The value to convert.\n * @param option The option for which the value should be converted.\n * @returns The result of the conversion. Might be the value or an error.\n */\nexport function convert<T extends DeclarationOption>(\n    value: unknown,\n    option: T\n): DeclarationOptionToOptionType<T>;\nexport function convert<T>(value: unknown, option: MapDeclarationOption<T>): T;\nexport function convert(value: unknown, option: DeclarationOption): unknown {\n    switch (option.type) {\n        case undefined:\n        case ParameterType.String: {\n            const stringValue = value == null ? \"\" : String(value);\n            if (option.validate) {\n                option.validate(stringValue);\n            }\n            return stringValue;\n        }\n        case ParameterType.Number: {\n            const numValue = parseInt(String(value), 10) || 0;\n            if (\n                !valueIsWithinBounds(numValue, option.minValue, option.maxValue)\n            ) {\n                throw new Error(\n                    getBoundsError(\n                        option.name,\n                        option.minValue,\n                        option.maxValue\n                    )\n                );\n            }\n            if (option.validate) {\n                option.validate(numValue);\n            }\n            return numValue;\n        }\n\n        case ParameterType.Boolean:\n            return Boolean(value);\n\n        case ParameterType.Array: {\n            let strArrValue = new Array<string>();\n            if (Array.isArray(value)) {\n                strArrValue = value.map(String);\n            } else if (typeof value === \"string\") {\n                strArrValue = value.split(\",\");\n            }\n            if (option.validate) {\n                option.validate(strArrValue);\n            }\n            return strArrValue;\n        }\n        case ParameterType.Map: {\n            const key = String(value).toLowerCase();\n            if (option.map instanceof Map) {\n                if (option.map.has(key)) {\n                    return option.map.get(key);\n                } else if ([...option.map.values()].includes(value)) {\n                    return value;\n                }\n            } else if (key in option.map) {\n                return option.map[key];\n            } else if (Object.values(option.map).includes(value)) {\n                return value;\n            }\n            throw new Error(\n                option.mapError ?? getMapError(option.map, option.name)\n            );\n        }\n        case ParameterType.Mixed:\n            if (option.validate) {\n                option.validate(value);\n            }\n            return value;\n    }\n}\n\n/**\n * Returns an error message for a map option, indicating that a given value was not one of the values within the map.\n * @param map The values for the option.\n * @param name The name of the option.\n * @returns The error message.\n */\nfunction getMapError(\n    map: MapDeclarationOption<unknown>[\"map\"],\n    name: string\n): string {\n    let keys = map instanceof Map ? [...map.keys()] : Object.keys(map);\n    const getString = (key: string) =>\n        String(map instanceof Map ? map.get(key) : map[key]);\n\n    // If the map is a TS numeric enum we need to filter out the numeric keys.\n    // TS numeric enums have the property that every key maps to a value, which maps back to that key.\n    if (\n        !(map instanceof Map) &&\n        keys.every((key) => getString(getString(key)) === key)\n    ) {\n        // This works because TS enum keys may not be numeric.\n        keys = keys.filter((key) => Number.isNaN(parseInt(key, 10)));\n    }\n\n    return `${name} must be one of ${keys.join(\", \")}`;\n}\n\n/**\n * Returns an error message for a value that is out of bounds of the given min and/or max values.\n * @param name The name of the thing the value represents.\n * @param minValue The lower bound of the range of allowed values.\n * @param maxValue The upper bound of the range of allowed values.\n * @returns The error message.\n */\nfunction getBoundsError(\n    name: string,\n    minValue?: number,\n    maxValue?: number\n): string {\n    if (isFiniteNumber(minValue) && isFiniteNumber(maxValue)) {\n        return `${name} must be between ${minValue} and ${maxValue}`;\n    } else if (isFiniteNumber(minValue)) {\n        return `${name} must be >= ${minValue}`;\n    } else if (isFiniteNumber(maxValue)) {\n        return `${name} must be <= ${maxValue}`;\n    }\n    throw new Error(\"Unreachable\");\n}\n\n/**\n * Checks if the given value is a finite number.\n * @param value The value being checked.\n * @returns True, if the value is a finite number, otherwise false.\n */\nfunction isFiniteNumber(value: unknown): value is number {\n    return Number.isFinite(value);\n}\n\n/**\n * Checks if a value is between the bounds of the given min and/or max values.\n * @param value The value being checked.\n * @param minValue The lower bound of the range of allowed values.\n * @param maxValue The upper bound of the range of allowed values.\n * @returns True, if the value is within the given bounds, otherwise false.\n */\nfunction valueIsWithinBounds(\n    value: number,\n    minValue?: number,\n    maxValue?: number\n): boolean {\n    if (isFiniteNumber(minValue) && isFiniteNumber(maxValue)) {\n        return minValue <= value && value <= maxValue;\n    } else if (isFiniteNumber(minValue)) {\n        return minValue <= value;\n    } else if (isFiniteNumber(maxValue)) {\n        return value <= maxValue;\n    } else {\n        return true;\n    }\n}\n"]}
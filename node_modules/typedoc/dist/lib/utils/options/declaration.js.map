{"version":3,"file":"declaration.js","sourceRoot":"","sources":["../../../../src/lib/utils/options/declaration.ts"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash';\nimport { CompilerOptions } from 'typescript';\nimport { IgnoredTsOptionKeys } from './sources/typescript';\n\n/**\n * An interface describing all TypeDoc specific options options. Generated from a\n * map which contains more information about each option for better types when\n * defining said options.\n */\nexport type TypeDocOptions = {\n    [K in keyof TypeDocOptionMap]: TypeDocOptionMap[K] extends Record<string, infer U>\n        ? Exclude<U, string> | keyof TypeDocOptionMap[K]\n        : TypeDocOptionMap[K];\n};\n\n/**\n * The CompilerOptions interface includes an index signature to avoid errors when unknown\n * options are passed. TypeDoc's option parsing is stricter, so we need to remove it.\n *\n * @see https://github.com/Microsoft/TypeScript/issues/25987#issuecomment-408339599\n */\ntype KnownKeys<T> = {\n    [K in keyof T]: string extends K ? never : number extends K ? never : K\n} extends {[_ in keyof T]: infer U} ? U : never;\n\n/**\n * All supported options, includes both TypeDoc and TypeScript options.\n */\nexport type TypeDocAndTSOptions = TypeDocOptions\n    & Pick<CompilerOptions, Exclude<KnownKeys<CompilerOptions>, IgnoredTsOptionKeys>>;\n\nexport enum SourceFileMode {\n    File, Modules\n}\n\n/**\n * Describes all TypeDoc options. Used internally to provide better types when fetching options.\n * External consumers should likely use either [[TypeDocAndTSOptions]] or [[TypeDocOptions]].\n */\nexport interface TypeDocOptionMap {\n    options: string;\n    tsconfig: string;\n\n    inputFiles: string[];\n    mode: { file: SourceFileMode.File, modules: SourceFileMode.Modules };\n    includeDeclarations: boolean;\n    entryPoint: string;\n    exclude: string[];\n    externalPattern: string[];\n    excludeExternals: boolean;\n    excludeNotExported: boolean;\n    excludePrivate: boolean;\n    excludeProtected: boolean;\n    excludeNotDocumented: boolean;\n    ignoreCompilerErrors: boolean;\n    disableSources: boolean;\n    includes: string;\n    media: string;\n\n    out: string;\n    json: string;\n\n    theme: string;\n    name: string;\n    includeVersion: boolean;\n    excludeTags: string[];\n    readme: string;\n    defaultCategory: string;\n    categoryOrder: string[];\n    categorizeByGroup: boolean;\n    gitRevision: string;\n    gitRemote: string;\n    gaID: string;\n    gaSite: string;\n    hideGenerator: boolean;\n    toc: string[];\n    disableOutputCheck: boolean;\n\n    help: boolean;\n    version: boolean;\n    plugin: string[];\n    logger: unknown; // string | Function\n    listInvalidSymbolLinks: boolean;\n}\n\n/**\n * Converts a given TypeDoc option key to the type of the declaration expected.\n */\nexport type KeyToDeclaration<K extends keyof TypeDocOptionMap> =\n    TypeDocOptionMap[K] extends boolean ? BooleanDeclarationOption :\n    TypeDocOptionMap[K] extends string ? StringDeclarationOption :\n    TypeDocOptionMap[K] extends number ? NumberDeclarationOption :\n    TypeDocOptionMap[K] extends string[] ? ArrayDeclarationOption :\n    unknown extends TypeDocOptionMap[K] ? MixedDeclarationOption :\n    TypeDocOptionMap[K] extends Record<string | number, infer U> ? MapDeclarationOption<U> :\n    never;\n\nexport enum ParameterHint {\n    File,\n    Directory\n}\n\nexport enum ParameterType {\n    String,\n    Number,\n    Boolean,\n    Map,\n    Mixed,\n    Array\n}\n\nexport enum ParameterScope {\n    TypeDoc,\n    TypeScript\n}\n\nexport interface DeclarationOptionBase {\n    /**\n     * The option name.\n     */\n    name: string;\n\n    /**\n     * An optional short name for the option.\n     */\n    short?: string;\n\n    /**\n     * The help text to be displayed to the user when --help is passed.\n     */\n    help: string;\n\n    /**\n     * The parameter type, used to convert user configuration values into the expected type.\n     * If not set, the type will be a string.\n     */\n    type?: ParameterType;\n\n    /**\n     * Whether the option belongs to TypeDoc or TypeScript.\n     * If not specified will be defaulted to TypeDoc.\n     */\n    scope?: ParameterScope;\n}\n\nexport interface StringDeclarationOption extends DeclarationOptionBase {\n    type?: ParameterType.String;\n\n    /**\n     * If not specified defaults to the empty string.\n     */\n    defaultValue?: string;\n\n    /**\n     * An optional hint for the type of input expected, will be displayed in the help output.\n     */\n    hint?: ParameterHint;\n}\n\nexport interface NumberDeclarationOption extends DeclarationOptionBase {\n    type: ParameterType.Number;\n\n    /**\n     * Lowest possible value.\n     */\n    minValue?: number;\n\n    /**\n     * Highest possible value.\n     */\n    maxValue?: number;\n\n    /**\n     * If not specified defaults to 0.\n     */\n    defaultValue?: number;\n}\n\nexport interface BooleanDeclarationOption extends DeclarationOptionBase {\n    type: ParameterType.Boolean;\n\n    /**\n     * If not specified defaults to false.\n     */\n    defaultValue?: boolean;\n}\n\nexport interface ArrayDeclarationOption extends DeclarationOptionBase {\n    type: ParameterType.Array;\n\n    /**\n     * If not specified defaults to an empty array.\n     */\n    defaultValue?: string[];\n}\n\nexport interface MixedDeclarationOption extends DeclarationOptionBase {\n    type: ParameterType.Mixed;\n\n    /**\n     * If not specified defaults to undefined.\n     */\n    defaultValue?: unknown;\n}\n\nexport interface MapDeclarationOption<T> extends DeclarationOptionBase {\n    type: ParameterType.Map;\n    /**\n     * Maps a given value to the option type. The map type may be a TypeScript enum.\n     * In that case, when generating an error message for a mismatched key, the numeric\n     * keys will not be listed.\n     */\n    map: Map<string, T> | Record<string | number, T>;\n\n    /**\n     * Unlike the rest of the option types, there is no sensible generic default for mapped option types.\n     * The default value for a mapped type must be specified.\n     */\n    defaultValue: T;\n\n    /**\n     * Optional override for the error reported when an invalid key is provided.\n     */\n    mapError?: string;\n}\n\nexport type DeclarationOption =\n    | StringDeclarationOption\n    | NumberDeclarationOption\n    | BooleanDeclarationOption\n    | MixedDeclarationOption\n    | MapDeclarationOption<unknown>\n    | ArrayDeclarationOption;\n\nexport type DeclarationOptionToOptionType<T extends DeclarationOption> =\n    T extends StringDeclarationOption ? string :\n    T extends NumberDeclarationOption ? number :\n    T extends BooleanDeclarationOption ? boolean :\n    T extends MixedDeclarationOption ? unknown :\n    T extends MapDeclarationOption<infer U> ? U :\n    T extends ArrayDeclarationOption ? string[] :\n    never;\n\n/**\n * The default conversion function used by the Options container. Readers may\n * re-use this conversion function or implement their own. The arguments reader\n * implements its own since 'false' should not be converted to true for a boolean option.\n * @param value The value to convert.\n * @param option The option for which the value should be converted.\n * @returns The result of the conversion. Might be the value or an error.\n */\nexport function convert<T extends DeclarationOption>(value: unknown, option: T): DeclarationOptionToOptionType<T>;\nexport function convert<T extends DeclarationOption>(value: unknown, option: T): unknown {\n    switch (option.type) {\n        case undefined:\n        case ParameterType.String:\n            return value == null ? '' : String(value);\n        case ParameterType.Number:\n            const numberOption = option as NumberDeclarationOption;\n            const numValue = parseInt(String(value), 10) || 0;\n            if (!valueIsWithinBounds(numValue, numberOption.minValue, numberOption.maxValue)) {\n                throw new Error(getBoundsError(numberOption.name, numberOption.minValue, numberOption.maxValue));\n            }\n            return numValue;\n        case ParameterType.Boolean:\n            return Boolean(value);\n        case ParameterType.Array:\n            if (Array.isArray(value)) {\n                return value.map(String);\n            } else if (typeof value === 'string') {\n                return value.split(',');\n            }\n            return [];\n        case ParameterType.Map:\n            const optionMap = option as MapDeclarationOption<unknown>;\n            const key = String(value).toLowerCase();\n            if (optionMap.map instanceof Map) {\n                if (optionMap.map.has(key)) {\n                    return optionMap.map.get(key);\n                }\n                if ([...optionMap.map.values()].includes(value)) {\n                    return value;\n                }\n            } else {\n                if (optionMap.map.hasOwnProperty(key)) {\n                    return optionMap.map[key];\n                }\n                if (Object.values(optionMap.map).includes(value)) {\n                    return value;\n                }\n            }\n            throw new Error(optionMap.mapError ?? getMapError(optionMap.map, optionMap.name));\n        case ParameterType.Mixed:\n            return value;\n    }\n}\n\n/**\n * Returns an error message for a map option, indicating that a given value was not one of the values within the map.\n * @param map The values for the option.\n * @param name The name of the option.\n * @returns The error message.\n */\nfunction getMapError(map: MapDeclarationOption<unknown>['map'], name: string): string {\n    let keys = map instanceof Map ? [...map.keys()] : Object.keys(map);\n    const getString = (key: string) => String(map instanceof Map ? map.get(key) : map[key]);\n\n    // If the map is a TS numeric enum we need to filter out the numeric keys.\n    // TS numeric enums have the property that every key maps to a value, which maps back to that key.\n    if (!(map instanceof Map) && keys.every(key => getString(getString(key)) === key)) {\n        // This works because TS enum keys may not be numeric.\n        keys = keys.filter(key => Number.isNaN(parseInt(key, 10)));\n    }\n\n    return `${name} must be one of ${keys.join(', ')}`;\n}\n\n/**\n * Returns an error message for a value that is out of bounds of the given min and/or max values.\n * @param name The name of the thing the value represents.\n * @param minValue The lower bound of the range of allowed values.\n * @param maxValue The upper bound of the range of allowed values.\n * @returns The error message.\n */\nfunction getBoundsError(name: string, minValue?: number, maxValue?: number): string {\n    if (isFiniteNumber(minValue) && isFiniteNumber(maxValue)) {\n        return `${name} must be between ${minValue} and ${maxValue}`;\n    } else if (isFiniteNumber(minValue)) {\n        return `${name} must be >= ${minValue}`;\n    } else if (isFiniteNumber(maxValue)) {\n        return `${name} must be <= ${maxValue}`;\n    }\n    throw new Error('Unreachable');\n}\n\n/**\n * Checks if the given value is a finite number.\n * This is equivalent to Number.isFinite, but that function is incorrectly typed to only accept\n * `number` in the latest TS version. See TypeScript/34932\n * @param value The value being checked.\n * @returns True, if the value is a finite number, otherwise false.\n */\nfunction isFiniteNumber(value?: unknown): value is number {\n    return typeof value === 'number' && isFinite(value);\n}\n\n/**\n * Checks if a value is between the bounds of the given min and/or max values.\n * @param value The value being checked.\n * @param minValue The lower bound of the range of allowed values.\n * @param maxValue The upper bound of the range of allowed values.\n * @returns True, if the value is within the given bounds, otherwise false.\n */\nfunction valueIsWithinBounds(value: number, minValue?: number, maxValue?: number): boolean {\n    if (isFiniteNumber(minValue) && isFiniteNumber(maxValue)) {\n        return minValue <= value && value <= maxValue;\n    } else if (isFiniteNumber(minValue)) {\n        return minValue <= value;\n    } else if (isFiniteNumber(maxValue)) {\n        return value <= maxValue;\n    } else {\n        return true;\n    }\n}\n"]}
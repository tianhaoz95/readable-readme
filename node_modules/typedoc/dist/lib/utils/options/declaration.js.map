{"version":3,"file":"declaration.js","sourceRoot":"","sources":["../../../../src/lib/utils/options/declaration.ts"],"names":[],"mappings":";;AAEA,sCAAmC;AA8BnC,IAAY,cAEX;AAFD,WAAY,cAAc;IACtB,mDAAI,CAAA;IAAE,yDAAO,CAAA;AACjB,CAAC,EAFW,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAEzB;AA6DD,IAAY,aAGX;AAHD,WAAY,aAAa;IACrB,iDAAI,CAAA;IACJ,2DAAS,CAAA;AACb,CAAC,EAHW,aAAa,GAAb,qBAAa,KAAb,qBAAa,QAGxB;AAED,IAAY,aAOX;AAPD,WAAY,aAAa;IACrB,qDAAM,CAAA;IACN,qDAAM,CAAA;IACN,uDAAO,CAAA;IACP,+CAAG,CAAA;IACH,mDAAK,CAAA;IACL,mDAAK,CAAA;AACT,CAAC,EAPW,aAAa,GAAb,qBAAa,KAAb,qBAAa,QAOxB;AAED,IAAY,cAGX;AAHD,WAAY,cAAc;IACtB,yDAAO,CAAA;IACP,+DAAU,CAAA;AACd,CAAC,EAHW,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAGzB;AAgID,SAAgB,OAAO,CAA8B,KAAc,EAAE,MAAS;;IAC1E,QAAQ,MAAM,CAAC,IAAI,EAAE;QACjB,KAAK,SAAS,CAAC;QACf,KAAK,aAAa,CAAC,MAAM;YACrB,OAAO,eAAM,CAAC,EAAE,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;QACzD,KAAK,aAAa,CAAC,MAAM;YACrB,OAAO,eAAM,CAAC,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;QACvD,KAAK,aAAa,CAAC,OAAO;YACtB,OAAO,eAAM,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;QACrC,KAAK,aAAa,CAAC,KAAK;YACpB,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;gBACtB,OAAO,eAAM,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;aACvC;iBAAM,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;gBAClC,OAAO,eAAM,CAAC,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;aACtC;YACD,OAAO,eAAM,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACzB,KAAK,aAAa,CAAC,GAAG;YAClB,MAAM,SAAS,GAAG,MAAuC,CAAC;YAC1D,MAAM,GAAG,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,WAAW,EAAE,CAAC;YACxC,IAAI,SAAS,CAAC,GAAG,YAAY,GAAG,EAAE;gBAC9B,IAAI,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;oBACxB,OAAO,eAAM,CAAC,EAAE,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;iBAC5C;gBACD,IAAI,CAAC,GAAG,SAAS,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;oBAC7C,OAAO,eAAM,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC;iBAC3B;aACJ;iBAAM;gBACH,IAAI,SAAS,CAAC,GAAG,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;oBACnC,OAAO,eAAM,CAAC,EAAE,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;iBACxC;gBACD,IAAI,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;oBAC9C,OAAO,eAAM,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC;iBAC3B;aACJ;YACD,OAAO,eAAM,CAAC,GAAG,OAAC,SAAS,CAAC,QAAQ,uCAAI,WAAW,CAAC,SAAS,CAAC,GAAG,EAAE,SAAS,CAAC,IAAI,CAAC,GAAC,CAAC;QACxF,KAAK,aAAa,CAAC,KAAK;YACpB,OAAO,eAAM,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC;KAC/B;AACL,CAAC;AAtCD,0BAsCC;AAED,SAAS,WAAW,CAAC,GAAyC,EAAE,IAAY;IACxE,IAAI,IAAI,GAAG,GAAG,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACnE,MAAM,SAAS,GAAG,CAAC,GAAW,EAAE,EAAE,CAAC,MAAM,CAAC,GAAG,YAAY,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IAIxF,IAAI,CAAC,CAAC,GAAG,YAAY,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,SAAS,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC,EAAE;QAE/E,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;KAC9D;IAED,OAAO,GAAG,IAAI,mBAAmB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;AACvD,CAAC","sourcesContent":["import * as _ from 'lodash';\nimport { CompilerOptions } from 'typescript';\nimport { Result } from '../result';\nimport { IgnoredTsOptionKeys } from './sources/typescript';\n\n/**\n * An interface describing all TypeDoc specific options options. Generated from a\n * map which contains more information about each option for better types when\n * defining said options.\n */\nexport type TypeDocOptions = {\n    [K in keyof TypeDocOptionMap]: TypeDocOptionMap[K] extends Record<string, infer U>\n        ? Exclude<U, string> | keyof TypeDocOptionMap[K]\n        : TypeDocOptionMap[K];\n};\n\n/**\n * The CompilerOptions interface includes an index signature to avoid errors when unknown\n * options are passed. TypeDoc's option parsing is stricter, so we need to remove it.\n *\n * @see https://github.com/Microsoft/TypeScript/issues/25987#issuecomment-408339599\n */\ntype KnownKeys<T> = {\n    [K in keyof T]: string extends K ? never : number extends K ? never : K\n} extends {[_ in keyof T]: infer U} ? U : never;\n\n/**\n * All supported options, includes both TypeDoc and TypeScript options.\n */\nexport type TypeDocAndTSOptions = TypeDocOptions\n    & Pick<CompilerOptions, Exclude<KnownKeys<CompilerOptions>, IgnoredTsOptionKeys>>;\n\nexport enum SourceFileMode {\n    File, Modules\n}\n\n/**\n * Describes all TypeDoc options. Used internally to provide better types when fetching options.\n * External consumers should likely use either [[TypeDocAndTSOptions]] or [[TypeDocOptions]].\n */\nexport interface TypeDocOptionMap {\n    options: string;\n    tsconfig: string;\n\n    inputFiles: string[];\n    mode: { file: SourceFileMode.File, modules: SourceFileMode.Modules };\n    includeDeclarations: boolean;\n    entryPoint: string;\n    exclude: string[];\n    externalPattern: string[];\n    excludeExternals: boolean;\n    excludeNotExported: boolean;\n    excludePrivate: boolean;\n    excludeProtected: boolean;\n    ignoreCompilerErrors: boolean;\n    includes: string;\n    media: string;\n\n    out: string;\n    json: string;\n\n    theme: string;\n    name: string;\n    includeVersion: boolean;\n    excludeTags: string[];\n    readme: string;\n    defaultCategory: string;\n    categoryOrder: string[];\n    categorizeByGroup: boolean;\n    gitRevision: string;\n    gaID: string;\n    gaSite: string;\n    hideGenerator: boolean;\n    toc: string[];\n    disableOutputCheck: boolean;\n\n    help: boolean;\n    version: boolean;\n    plugin: string[];\n    logger: unknown; // string | Function\n    listInvalidSymbolLinks: boolean;\n}\n\n/**\n * Converts a given TypeDoc option key to the type of the declaration expected.\n */\nexport type KeyToDeclaration<K extends keyof TypeDocOptionMap> =\n    TypeDocOptionMap[K] extends boolean ? BooleanDeclarationOption :\n    TypeDocOptionMap[K] extends string ? StringDeclarationOption :\n    TypeDocOptionMap[K] extends number ? NumberDeclarationOption :\n    TypeDocOptionMap[K] extends string[] ? ArrayDeclarationOption :\n    unknown extends TypeDocOptionMap[K] ? MixedDeclarationOption :\n    TypeDocOptionMap[K] extends Record<string | number, infer U> ? MapDeclarationOption<U> :\n    never;\n\nexport enum ParameterHint {\n    File,\n    Directory\n}\n\nexport enum ParameterType {\n    String,\n    Number,\n    Boolean,\n    Map,\n    Mixed,\n    Array\n}\n\nexport enum ParameterScope {\n    TypeDoc,\n    TypeScript\n}\n\nexport interface DeclarationOptionBase {\n    /**\n     * The option name.\n     */\n    name: string;\n\n    /**\n     * An optional short name for the option.\n     */\n    short?: string;\n\n    /**\n     * The help text to be displayed to the user when --help is passed.\n     */\n    help: string;\n\n    /**\n     * The parameter type, used to convert user configuration values into the expected type.\n     * If not set, the type will be a string.\n     */\n    type?: ParameterType;\n\n    /**\n     * Whether the option belongs to TypeDoc or TypeScript.\n     * If not specified will be defaulted to TypeDoc.\n     */\n    scope?: ParameterScope;\n}\n\nexport interface StringDeclarationOption extends DeclarationOptionBase {\n    type?: ParameterType.String;\n\n    /**\n     * If not specified defaults to the empty string.\n     */\n    defaultValue?: string;\n\n    /**\n     * An optional hint for the type of input expected, will be displayed in the help output.\n     */\n    hint?: ParameterHint;\n}\n\nexport interface NumberDeclarationOption extends DeclarationOptionBase {\n    type: ParameterType.Number;\n\n    /**\n     * If not specified defaults to 0.\n     */\n    defaultValue?: number;\n}\n\nexport interface BooleanDeclarationOption extends DeclarationOptionBase {\n    type: ParameterType.Boolean;\n\n    /**\n     * If not specified defaults to false.\n     */\n    defaultValue?: boolean;\n}\n\nexport interface ArrayDeclarationOption extends DeclarationOptionBase {\n    type: ParameterType.Array;\n\n    /**\n     * If not specified defaults to an empty array.\n     */\n    defaultValue?: string[];\n}\n\nexport interface MixedDeclarationOption extends DeclarationOptionBase {\n    type: ParameterType.Mixed;\n\n    /**\n     * If not specified defaults to undefined.\n     */\n    defaultValue?: unknown;\n}\n\nexport interface MapDeclarationOption<T> extends DeclarationOptionBase {\n    type: ParameterType.Map;\n    /**\n     * Maps a given value to the option type. The map type may be a TypeScript enum.\n     * In that case, when generating an error message for a mismatched key, the numeric\n     * keys will not be listed.\n     */\n    map: Map<string, T> | Record<string | number, T>;\n\n    /**\n     * Unlike the rest of the option types, there is no sensible generic default for mapped option types.\n     * The default value for a mapped type must be specified.\n     */\n    defaultValue: T;\n\n    /**\n     * Optional override for the error reported when an invalid key is provided.\n     */\n    mapError?: string;\n}\n\nexport type DeclarationOption =\n    | StringDeclarationOption\n    | NumberDeclarationOption\n    | BooleanDeclarationOption\n    | MixedDeclarationOption\n    | MapDeclarationOption<unknown>\n    | ArrayDeclarationOption;\n\nexport type DeclarationOptionToOptionType<T extends DeclarationOption> =\n    T extends StringDeclarationOption ? string :\n    T extends NumberDeclarationOption ? number :\n    T extends BooleanDeclarationOption ? boolean :\n    T extends MixedDeclarationOption ? unknown :\n    T extends MapDeclarationOption<infer U> ? U :\n    T extends ArrayDeclarationOption ? string[] :\n    never;\n\n/**\n * The default conversion function used by the Options container. Readers may\n * re-use this conversion function or implement their own. The arguments reader\n * implements its own since 'false' should not be converted to true for a boolean option.\n *\n * @param value\n * @param option\n */\nexport function convert<T extends DeclarationOption>(value: unknown, option: T): Result<DeclarationOptionToOptionType<T>, string>;\nexport function convert<T extends DeclarationOption>(value: unknown, option: T): Result<unknown, string> {\n    switch (option.type) {\n        case undefined:\n        case ParameterType.String:\n            return Result.Ok(value == null ? '' : String(value));\n        case ParameterType.Number:\n            return Result.Ok(parseInt(String(value), 10) || 0);\n        case ParameterType.Boolean:\n            return Result.Ok(Boolean(value));\n        case ParameterType.Array:\n            if (Array.isArray(value)) {\n                return Result.Ok(value.map(String));\n            } else if (typeof value === 'string') {\n                return Result.Ok(value.split(','));\n            }\n            return Result.Ok([]);\n        case ParameterType.Map:\n            const optionMap = option as MapDeclarationOption<unknown>;\n            const key = String(value).toLowerCase();\n            if (optionMap.map instanceof Map) {\n                if (optionMap.map.has(key)) {\n                    return Result.Ok(optionMap.map.get(key));\n                }\n                if ([...optionMap.map.values()].includes(value)) {\n                    return Result.Ok(value);\n                }\n            } else {\n                if (optionMap.map.hasOwnProperty(key)) {\n                    return Result.Ok(optionMap.map[key]);\n                }\n                if (Object.values(optionMap.map).includes(value)) {\n                    return Result.Ok(value);\n                }\n            }\n            return Result.Err(optionMap.mapError ?? getMapError(optionMap.map, optionMap.name));\n        case ParameterType.Mixed:\n            return Result.Ok(value);\n    }\n}\n\nfunction getMapError(map: MapDeclarationOption<unknown>['map'], name: string) {\n    let keys = map instanceof Map ? [...map.keys()] : Object.keys(map);\n    const getString = (key: string) => String(map instanceof Map ? map.get(key) : map[key]);\n\n    // If the map is a TS numeric enum we need to filter out the numeric keys.\n    // TS numeric enums have the property that every key maps to a value, which maps back to that key.\n    if (!(map instanceof Map) && keys.every(key => getString(getString(key)) === key)) {\n        // This works because TS enum keys may not be numeric.\n        keys = keys.filter(key => Number.isNaN(parseInt(key, 10)));\n    }\n\n    return `${name} must be one of ${keys.join(', ')}`;\n}\n"]}
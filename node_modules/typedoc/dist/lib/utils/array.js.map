{"version":3,"file":"array.js","sourceRoot":"","sources":["../../../src/lib/utils/array.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Inserts an item into an array sorted by priority. If two items have the same priority,\n * the item will be inserted later will be placed earlier in the array.\n * @param arr modified by inserting item.\n * @param item\n */\nexport function insertPrioritySorted<T extends { priority: number }>(\n    arr: T[],\n    item: T\n): T[] {\n    const index = binaryFindPartition(arr, (v) => v.priority >= item.priority);\n    arr.splice(index === -1 ? arr.length : index, 0, item);\n    return arr;\n}\n\n/**\n * Performs a binary search of a given array, returning the index of the first item\n * for which `partition` returns true. Returns the -1 if there are no items in `arr`\n * such that `partition(item)` is true.\n * @param arr\n * @param partition should return true while less than the partition point.\n */\nexport function binaryFindPartition<T>(\n    arr: readonly T[],\n    partition: (item: T) => boolean\n): number {\n    if (arr.length === 0) {\n        return -1;\n    }\n\n    let low = 0,\n        high = arr.length - 1;\n\n    while (high > low) {\n        const mid = low + Math.floor((high - low) / 2);\n        if (partition(arr[mid])) {\n            high = mid;\n        } else {\n            low = mid + 1;\n        }\n    }\n\n    return partition(arr[low]) ? low : -1;\n}\n\n/**\n * Removes an item from the array if the array exists and the item is included\n * within it.\n * @param arr\n * @param item\n */\nexport function removeIfPresent<T>(arr: T[] | undefined, item: T) {\n    if (!arr) {\n        return;\n    }\n    const index = arr.indexOf(item);\n    if (index !== -1) {\n        arr.splice(index, 1);\n    }\n}\n\n/**\n * Remove items in an array which match a predicate.\n * @param arr\n * @param predicate\n */\nexport function removeIf<T>(arr: T[], predicate: (item: T) => boolean) {\n    const indices = filterMap(arr, (item, index) =>\n        predicate(item) ? index : void 0\n    );\n    for (const index of indices.reverse()) {\n        arr.splice(index, 1);\n    }\n}\n\n/**\n * Filters out duplicate values from the given iterable.\n * @param arr\n */\nexport function unique<T>(arr: Iterable<T> | undefined): T[] {\n    return Array.from(new Set(arr));\n}\n\n/**\n * Filters out duplicate values from the given array with a custom equals check.\n * @param arr\n */\nexport function uniqueByEquals<T extends { equals(other: T): boolean }>(\n    arr: readonly T[] | undefined\n) {\n    const result: T[] = [];\n\n    for (const item of arr ?? []) {\n        if (result.every((other) => !other.equals(item))) {\n            result.push(item);\n        }\n    }\n\n    return result;\n}\n\n/**\n * Ensures the given item is an array.\n * @param item\n */\nexport function toArray<T>(item: T | readonly T[] | undefined): T[] {\n    if (item === void 0) {\n        return [];\n    }\n    return Array.isArray(item) ? [...item] : [item];\n}\n\nexport function* zip<T extends Iterable<any>[]>(\n    ...args: T\n): Iterable<{ [K in keyof T]: T[K] extends Iterable<infer U> ? U : T[K] }> {\n    const iterators = args.map((x) => x[Symbol.iterator]());\n\n    while (true) {\n        const next = iterators.map((i) => i.next());\n        if (next.some((v) => v.done)) {\n            break;\n        }\n        yield next.map((v) => v.value) as any;\n    }\n}\n\nexport function filterMap<T, U>(\n    arr: readonly T[],\n    fn: (item: T, index: number) => U | undefined\n): U[] {\n    const result: U[] = [];\n\n    arr.forEach((item, index) => {\n        const newItem = fn(item, index);\n        if (newItem !== void 0) {\n            result.push(newItem);\n        }\n    });\n\n    return result;\n}\n\nexport function flatMap<T, U>(\n    arr: readonly T[],\n    fn: (item: T) => U | readonly U[]\n): U[] {\n    const result: U[] = [];\n\n    for (const item of arr) {\n        const newItem = fn(item);\n        if (newItem instanceof Array) {\n            result.push(...newItem);\n        } else {\n            result.push(newItem);\n        }\n    }\n\n    return result;\n}\n"]}
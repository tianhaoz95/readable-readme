{"version":3,"file":"reflection.js","sourceRoot":"","sources":["../../../../../src/lib/serialization/serializers/types/reflection.ts"],"names":[],"mappings":";;AAAA,4CAAwE;AAExE,iDAA2D;AAG3D,MAAa,wBAAyB,SAAQ,oCAAuC;IAArF;;QACY,YAAO,GAAG,IAAI,GAAG,EAAyB,CAAC;IAoCvD,CAAC;IAlCG,QAAQ,CAAC,CAAU;QACf,OAAO,CAAC,YAAY,uBAAc,CAAC;IACvC,CAAC;IAED,QAAQ,CAAC,SAAyB,EAAE,GAAqC;QACrE,MAAM,MAAM,qBACL,GAAG,CACT,CAAC;QAUF,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,WAAW,CAAC,EAAE;YAGzC,MAAM,CAAC,WAAW,GAAG,EAAE,EAAE,EAAE,SAAS,CAAC,WAAW,CAAC,EAAE,EAAE,CAAC;SACzD;aAAM;YAEH,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;YAGxC,MAAM,CAAC,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;SACnE;QAGD,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;QAE3C,OAAO,MAAM,CAAC;IAClB,CAAC;CACJ;AArCD,4DAqCC","sourcesContent":["import { DeclarationReflection, ReflectionType } from '../../../models';\n\nimport { TypeSerializerComponent } from '../../components';\nimport { ReflectionType as JSONReflectionType } from '../../schema';\n\nexport class ReflectionTypeSerializer extends TypeSerializerComponent<ReflectionType> {\n    private visited = new Set<DeclarationReflection>();\n\n    supports(t: unknown) {\n        return t instanceof ReflectionType;\n    }\n\n    toObject(reference: ReflectionType, obj: Pick<JSONReflectionType, 'type'>): JSONReflectionType {\n        const result: JSONReflectionType = {\n            ...obj\n        };\n\n        // Because `DeclarationReflection` has reference to multiple types objectifying a declaration\n        // on a type might fall into a loop trap (cyclic dependency).\n        // The TypeDoc code does not apply logic that can create this scenario but a 3rd party plugin\n        // might do that unintentionally so a protection is in place.\n        // TODO: Should this protection really be here? It seems like it might make more sense to\n        // do this check in the DeclarationReflection serializer... if it should even be checked. In the\n        // old `.toObject` code, it wasn't checked.\n\n        if (this.visited.has(reference.declaration)) {\n            // if we're here it means that the reference type is rendered for the 2nd time\n            // by the declaration it is referencing, we will render a pointer-only declaration.\n            result.declaration = { id: reference.declaration.id };\n        } else {\n            // mark this declaration to trap a loop\n            this.visited.add(reference.declaration);\n\n            // objectify the declaration\n            result.declaration = this.owner.toObject(reference.declaration);\n        }\n\n        // no more declaration rendering, remove marker.\n        this.visited.delete(reference.declaration);\n\n        return result;\n    }\n}\n"]}
{"version":3,"file":"components.js","sourceRoot":"","sources":["../../../src/lib/serialization/components.ts"],"names":[],"mappings":";;;AAAA,sCAA6C;AAK7C;;;;;;;;;;;;GAYG;AACH,MAAsB,mBAAmB;IAOrC,YAAY,KAAiB;QACzB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACvB,CAAC;IA2BD;;;OAGG;IACH,IAAI,QAAQ;QACR,OAAO,CACF,IAAI,CAAC,WAA0C,CAAC,UAAU,CAAC;YAC5D,mBAAmB,CAAC,QAAQ,CAC/B,CAAC;IACN,CAAC;;AA7CL,kDAkDC;AAjDG;;;GAGG;AACI,4BAAQ,GAAG,CAAC,CAAC;AA+CxB,MAAsB,6BAEpB,SAAQ,mBAAsB;IAC5B;;OAEG;IACH,cAAc,CAAC,QAAiB;QAC5B,OAAO,QAAQ,YAAY,mBAAU,CAAC;IAC1C,CAAC;CACJ;AATD,sEASC;AAED,MAAsB,uBAEpB,SAAQ,mBAAsB;IAC5B;;OAEG;IACH,cAAc,CAAC,QAAiB;QAC5B,OAAO,QAAQ,YAAY,aAAI,CAAC;IACpC,CAAC;CACJ;AATD,0DASC","sourcesContent":["import { Reflection, Type } from \"../models\";\n\nimport { Serializer } from \"./serializer\";\nimport { ModelToObject } from \"./schema\";\n\n/**\n * Represents Serializer plugin component.\n *\n * Like [[Converter]] plugins each [[Serializer]] plugin defines a predicate that instructs if an\n * object can be serialized by it, this is done dynamically at runtime via a `supports` method.\n *\n * Additionally, each [[Serializer]] plugin must define a predicate that instructs the group\n * it belongs to.\n *\n * Serializers are grouped to improve performance when finding serializers that apply to a node,\n * this makes it possible to skip the `supports` calls for `Type`s when searching for a\n * `Reflection` and vise versa.\n */\nexport abstract class SerializerComponent<T> {\n    /**\n     * The priority this serializer should be executed with.\n     * A higher priority means the [[Serializer]] will be applied earlier.\n     */\n    static PRIORITY = 0;\n\n    constructor(owner: Serializer) {\n        this.owner = owner;\n    }\n\n    /**\n     * Set when the SerializerComponent is added to the serializer.\n     */\n    protected owner: Serializer;\n\n    /**\n     * A high-level predicate filtering which group this serializer belongs to.\n     * This is a high-level filter before the [[SerializerComponent.supports]] predicate filter.\n     *\n     * For example, use the [[Reflection]] class class to group all reflection based serializers:\n     * ```typescript\n     * class ReflectionSerializer {\n     *  serializeGroup(instance) { return instance instanceof Reflection }\n     * }\n     * ```\n     *\n     * Use the [[Type]] class to group all type based serializers:\n     * ```typescript\n     * class TypeSerializer {\n     *  serializeGroup(instance) { return instance instanceof Type }\n     * }\n     * ```\n     */\n    abstract serializeGroup(instance: unknown): boolean;\n\n    /**\n     * The priority this serializer should be executed with.\n     * A higher priority means the [[Serializer]] will be applied earlier.\n     */\n    get priority(): number {\n        return (\n            (this.constructor as typeof SerializerComponent)[\"PRIORITY\"] ||\n            SerializerComponent.PRIORITY\n        );\n    }\n\n    abstract supports(item: unknown): boolean;\n\n    abstract toObject(item: T, obj?: object): Partial<ModelToObject<T>>;\n}\n\nexport abstract class ReflectionSerializerComponent<\n    T extends Reflection\n> extends SerializerComponent<T> {\n    /**\n     * Filter for instances of [[Reflection]]\n     */\n    serializeGroup(instance: unknown): boolean {\n        return instance instanceof Reflection;\n    }\n}\n\nexport abstract class TypeSerializerComponent<\n    T extends Type\n> extends SerializerComponent<T> {\n    /**\n     * Filter for instances of [[Type]]\n     */\n    serializeGroup(instance: unknown): boolean {\n        return instance instanceof Type;\n    }\n}\n"]}
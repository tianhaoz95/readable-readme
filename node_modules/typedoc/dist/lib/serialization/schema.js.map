{"version":3,"file":"schema.js","sourceRoot":"","sources":["../../../src/lib/serialization/schema.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2BG","sourcesContent":["/**\n * Contains interfaces which describe the JSON output. Each interface is related to a specific type of serializer.\n *\n * ## Plugins\n * Plugins which modify the serialization process can use declaration merging\n * to add custom properties to the exported interfaces.\n * For example, if your custom serializer adds a property to all [[Reflection]] objects:\n * ```ts\n * declare module 'typedoc/dist/lib/serialization/schema' {\n *     export interface AbstractReflection {\n *         myCustomProp: boolean\n *     }\n * }\n * ```\n *\n * If a plugin defines a new Model type, [[ModelToObject]] will not pick up the serializer type and\n * the resulting type will not be included in the return type of {@link Serializer.toObject}.\n * To fix this, use declaration merging to augment the [[Serializer]] class.\n * ```ts\n * declare module 'typedoc/dist/lib/serialization/serializer' {\n *     export interface Serializer {\n *         toObject(value: CustomModel, obj?: Partial<CustomModel>): CustomOutput\n *     }\n * }\n * ```\n *\n * For documentation on the JSON output properties, view the corresponding model.\n */\n\n/** */\nimport * as M from \"../models\";\nimport { SourceReferenceWrapper, DecoratorWrapper } from \"./serializers\";\n\n/**\n * Describes the mapping from Model types to the corresponding JSON output type.\n */\nexport type ModelToObject<T> = T extends Array<infer U>\n    ? _ModelToObject<U>[]\n    : _ModelToObject<T>;\n\n// Order matters here. Some types are subtypes of other types.\ntype _ModelToObject<T> =\n    // Reflections\n    T extends Primitive\n        ? T\n        : T extends M.ReflectionGroup\n        ? ReflectionGroup\n        : T extends M.ReflectionCategory\n        ? ReflectionCategory\n        : T extends M.SignatureReflection\n        ? SignatureReflection\n        : T extends M.ParameterReflection\n        ? ParameterReflection\n        : T extends M.DeclarationReflection\n        ? DeclarationReflection\n        : T extends M.TypeParameterReflection\n        ? TypeParameterReflection\n        : T extends M.ProjectReflection\n        ? ProjectReflection\n        : T extends M.ContainerReflection\n        ? ContainerReflection\n        : T extends M.ReferenceReflection\n        ? ReferenceReflection\n        : T extends M.Reflection\n        ? Reflection\n        : // Types\n        T extends M.ArrayType\n        ? ArrayType\n        : T extends M.ConditionalType\n        ? ConditionalType\n        : T extends M.IndexedAccessType\n        ? IndexedAccessType\n        : T extends M.InferredType\n        ? InferredType\n        : T extends M.IntersectionType\n        ? IntersectionType\n        : T extends M.IntrinsicType\n        ? IntrinsicType\n        : T extends M.OptionalType\n        ? OptionalType\n        : T extends M.PredicateType\n        ? PredicateType\n        : T extends M.QueryType\n        ? QueryType\n        : T extends M.ReferenceType\n        ? ReferenceType\n        : T extends M.ReflectionType\n        ? ReflectionType\n        : T extends M.RestType\n        ? RestType\n        : T extends M.LiteralType\n        ? LiteralType\n        : T extends M.TupleType\n        ? TupleType\n        : T extends M.UnknownType\n        ? UnknownType\n        : T extends M.TemplateLiteralType\n        ? TemplateLiteralType\n        : T extends M.Type\n        ? SomeType // Technically AbstractType, but the union is more useful\n        : // Miscellaneous\n        T extends M.Comment\n        ? Comment\n        : T extends M.CommentTag\n        ? CommentTag\n        : T extends DecoratorWrapper\n        ? Decorator\n        : T extends SourceReferenceWrapper\n        ? SourceReference\n        : never;\n\ntype Primitive = string | number | undefined | null | boolean;\n\n// Separate helper so that we can trigger distribution.\ntype ToSerialized<T> = T extends Primitive\n    ? T\n    : T extends bigint\n    ? { value: string; negative: boolean }\n    : ModelToObject<T>;\n\n/**\n * Helper to describe a set of serialized properties. Primitive types are returned\n * directly, while other models are first passed through ModelToObject.\n * This helper removes the readonly modifier from properties since the result of serialization\n * is a plain object that consumers may modify as they choose, TypeDoc doesn't care.\n */\ntype S<T, K extends keyof T> = {\n    -readonly [K2 in K]: ToSerialized<T[K2]>;\n};\n\n// Reflections\n\nexport interface ReflectionGroup\n    extends S<M.ReflectionGroup, \"title\" | \"kind\" | \"categories\"> {\n    children?: M.ReflectionGroup[\"children\"][number][\"id\"][];\n}\n\nexport interface ReflectionCategory extends S<M.ReflectionCategory, \"title\"> {\n    children?: M.ReflectionCategory[\"children\"][number][\"id\"][];\n}\n\nexport interface ReferenceReflection\n    extends DeclarationReflection,\n        S<M.ReferenceReflection, never> {\n    /**\n     * -1 if the reference refers to a symbol that does not exist in the documentation.\n     * Otherwise, the reflection ID.\n     */\n    target: number;\n}\n\nexport interface SignatureReflection\n    extends Reflection,\n        S<\n            M.SignatureReflection,\n            | \"parameters\"\n            | \"type\"\n            | \"overwrites\"\n            | \"inheritedFrom\"\n            | \"implementationOf\"\n        > {\n    // Weird not to call this typeParameters... preserving backwards compatibility for now.\n    typeParameter?: ModelToObject<M.SignatureReflection[\"typeParameters\"]>;\n}\n\nexport interface ParameterReflection\n    extends Reflection,\n        S<M.ParameterReflection, \"type\" | \"defaultValue\"> {}\n\nexport interface DeclarationReflection\n    extends ContainerReflection,\n        S<\n            M.DeclarationReflection,\n            | \"type\"\n            | \"signatures\"\n            | \"indexSignature\"\n            | \"defaultValue\"\n            | \"overwrites\"\n            | \"inheritedFrom\"\n            | \"implementationOf\"\n            | \"extendedTypes\"\n            | \"extendedBy\"\n            | \"implementedTypes\"\n            | \"implementedBy\"\n        > {\n    // Weird not to call this typeParameters... preserving backwards compatibility for now.\n    typeParameter?: ModelToObject<M.DeclarationReflection[\"typeParameters\"]>;\n\n    // Yep... backwards compatibility. This is an optional one-tuple.\n    getSignature?: [ModelToObject<M.DeclarationReflection[\"getSignature\"]>];\n\n    // Yep... backwards compatibility. This is an optional one-tuple.\n    setSignature?: [ModelToObject<M.DeclarationReflection[\"setSignature\"]>];\n}\n\nexport interface TypeParameterReflection\n    extends Reflection,\n        S<M.TypeParameterReflection, \"type\" | \"default\"> {}\n\n// Nothing extra yet.\nexport interface ProjectReflection extends ContainerReflection {}\n\nexport interface ContainerReflection\n    extends Reflection,\n        S<M.ContainerReflection, \"children\" | \"groups\" | \"categories\"> {\n    sources?: ModelToObject<SourceReferenceWrapper[]>;\n}\n\nexport interface Reflection\n    extends S<\n        M.Reflection,\n        \"id\" | \"name\" | \"kind\" | \"kindString\" | \"comment\" | \"decorates\"\n    > {\n    /** Will not be present if name === originalName */\n    originalName?: M.Reflection[\"originalName\"];\n    flags: ReflectionFlags;\n    decorators?: ModelToObject<DecoratorWrapper[]>;\n}\n\n// Types\n\nexport type SomeType =\n    | ArrayType\n    | ConditionalType\n    | IndexedAccessType\n    | InferredType\n    | IntersectionType\n    | IntrinsicType\n    | LiteralType\n    | OptionalType\n    | PredicateType\n    | QueryType\n    | ReferenceType\n    | ReflectionType\n    | RestType\n    | TupleType\n    | TypeOperatorType\n    | TypeParameterType\n    | UnionType\n    | UnknownType;\n\nexport interface ArrayType\n    extends Type,\n        S<M.ArrayType, \"type\" | \"elementType\"> {}\n\nexport interface ConditionalType\n    extends Type,\n        S<\n            M.ConditionalType,\n            \"type\" | \"checkType\" | \"extendsType\" | \"trueType\" | \"falseType\"\n        > {}\n\nexport interface IndexedAccessType\n    extends Type,\n        S<M.IndexedAccessType, \"type\" | \"indexType\" | \"objectType\"> {}\n\nexport interface InferredType\n    extends Type,\n        S<M.InferredType, \"type\" | \"name\"> {}\n\nexport interface IntersectionType\n    extends Type,\n        S<M.IntersectionType, \"type\" | \"types\"> {}\n\nexport interface IntrinsicType\n    extends Type,\n        S<M.IntrinsicType, \"type\" | \"name\"> {}\n\nexport interface OptionalType\n    extends Type,\n        S<M.OptionalType, \"type\" | \"elementType\"> {}\n\nexport interface PredicateType\n    extends Type,\n        S<M.PredicateType, \"type\" | \"name\" | \"asserts\" | \"targetType\"> {}\n\nexport interface QueryType extends Type, S<M.QueryType, \"type\" | \"queryType\"> {}\n\nexport interface ReferenceType\n    extends Type,\n        S<M.ReferenceType, \"type\" | \"name\" | \"typeArguments\"> {\n    id?: number;\n}\n\nexport interface ReflectionType extends Type, S<M.ReflectionType, \"type\"> {\n    declaration?: ModelToObject<M.ReflectionType[\"declaration\"]>;\n}\n\nexport interface RestType extends Type, S<M.RestType, \"type\" | \"elementType\"> {}\n\nexport interface LiteralType extends Type, S<M.LiteralType, \"type\" | \"value\"> {}\n\nexport interface TupleType extends Type, S<M.TupleType, \"type\"> {\n    elements?: ModelToObject<M.TupleType[\"elements\"]>;\n}\n\nexport interface NamedTupleMemberType\n    extends Type,\n        S<M.NamedTupleMember, \"type\"> {\n    name: string;\n    isOptional: boolean;\n    element: ModelToObject<M.NamedTupleMember[\"element\"]>;\n}\n\nexport interface TemplateLiteralType\n    extends Type,\n        S<M.TemplateLiteralType, \"type\" | \"head\"> {\n    tail: [Type, string][];\n}\nexport interface MappedType\n    extends Type,\n        S<\n            M.MappedType,\n            | \"type\"\n            | \"parameter\"\n            | \"parameterType\"\n            | \"templateType\"\n            | \"readonlyModifier\"\n            | \"optionalModifier\"\n            | \"nameType\"\n        > {}\n\nexport interface TypeOperatorType\n    extends Type,\n        S<M.TypeOperatorType, \"type\" | \"operator\" | \"target\"> {}\n\nexport interface TypeParameterType\n    extends Type,\n        S<M.TypeParameterType, \"type\" | \"name\" | \"constraint\" | \"default\"> {}\n\nexport interface UnionType extends Type, S<M.UnionType, \"type\" | \"types\"> {}\n\nexport interface UnknownType extends Type, S<M.UnknownType, \"type\" | \"name\"> {}\n\n/**\n * Technically not correct, the `type` property will be set by the abstract serializer.\n * But to allow tagged literals, the `type` property is instead defined by each child type.\n */\nexport interface Type {}\n\n// Miscellaneous\n\ntype BoolKeys<T> = {\n    [K in keyof T]-?: T[K] extends boolean ? K : never;\n}[keyof T];\n\nexport interface ReflectionFlags\n    extends Partial<S<M.ReflectionFlags, BoolKeys<M.ReflectionFlags>>> {}\n\nexport interface Comment\n    extends Partial<S<M.Comment, \"shortText\" | \"text\" | \"returns\" | \"tags\">> {}\n\nexport interface CommentTag extends S<M.CommentTag, \"text\"> {\n    tag: M.CommentTag[\"tagName\"];\n    param?: M.CommentTag[\"paramName\"];\n}\n\nexport interface SourceReference\n    extends S<M.SourceReference, \"fileName\" | \"line\" | \"character\"> {}\n\nexport interface Decorator\n    extends S<M.Decorator, \"name\" | \"type\" | \"arguments\"> {}\n"]}
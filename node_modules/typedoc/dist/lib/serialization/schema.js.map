{"version":3,"file":"schema.js","sourceRoot":"","sources":["../../../src/lib/serialization/schema.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * Contains interfaces which describe the JSON output. Each interface is related to a specific type of serializer.\n *\n * ## Plugins\n * Plugins which modify the serialization process can use declaration merging\n * to add custom properties to the exported interfaces.\n * For example, if your custom serializer adds a property to all [[Reflection]] objects:\n * ```ts\n * declare module 'typedoc/dist/lib/serialization/schema' {\n *     export interface AbstractReflection {\n *         myCustomProp: boolean\n *     }\n * }\n * ```\n *\n * If a plugin defines a new Model type, [[ModelToObject]] will not pick up the serializer type and\n * the resulting type will not be included in the return type of {@link Serializer.toObject}.\n * To fix this, use declaration merging to augment the [[Serializer]] class.\n * ```ts\n * declare module 'typedoc/dist/lib/serialization/serializer' {\n *     export interface Serializer {\n *         toObject(value: CustomModel, obj?: Partial<CustomModel>): CustomOutput\n *     }\n * }\n * ```\n *\n * For documentation on the JSON output properties, view the corresponding model.\n */\n\n/** */\nimport * as M from '../models';\nimport { SourceReferenceWrapper, DecoratorWrapper } from './serializers';\n\n/**\n * Describes the mapping from Model types to the corresponding JSON output type.\n */\nexport type ModelToObject<T> = T extends Array<infer U> ? _ModelToObject<U>[] : _ModelToObject<T>;\n\n// Order matters here. Some types are subtypes of other types.\ntype _ModelToObject<T> =\n    // Reflections\n    T extends M.ReflectionGroup ? ReflectionGroup :\n    T extends M.ReflectionCategory ? ReflectionCategory :\n    T extends M.SignatureReflection ? SignatureReflection :\n    T extends M.ParameterReflection ? ParameterReflection :\n    T extends M.DeclarationReflection ? DeclarationReflection | ReflectionPointer :\n    T extends M.TypeParameterReflection ? TypeParameterReflection :\n    T extends M.ProjectReflection ? ProjectReflection :\n    T extends M.ContainerReflection ? ContainerReflection :\n    T extends M.ReferenceReflection ? ReferenceReflection :\n    T extends M.Reflection ? Reflection :\n    // Types\n    T extends M.ArrayType ? ArrayType :\n    T extends M.ConditionalType ? ConditionalType :\n    T extends M.IndexedAccessType ? IndexedAccessType :\n    T extends M.InferredType ? InferredType :\n    T extends M.IntersectionType ? IntersectionType :\n    T extends M.IntrinsicType ? IntrinsicType :\n    T extends M.PredicateType ? PredicateType :\n    T extends M.ReferenceType ? ReferenceType :\n    T extends M.ReflectionType ? ReflectionType :\n    T extends M.StringLiteralType ? StringLiteralType :\n    T extends M.TupleType ? TupleType :\n    T extends M.UnknownType ? UnknownType :\n    T extends M.Type ? SomeType : // Technically AbstractType, but the union is more useful\n    // Miscellaneous\n    T extends M.Comment ? Comment :\n    T extends M.CommentTag ? CommentTag :\n    T extends DecoratorWrapper ? Decorator :\n    T extends SourceReferenceWrapper ? SourceReference :\n    never;\n\ntype Primitive = string | number | undefined | null | boolean;\n\n/**\n * Helper to describe a set of serialized properties. Primitive types are returned\n * directly, while other models are first passed through ModelToObject.\n * This helper removes the readonly modifier from properties since the result of serialization\n * is a plain object that consumers may modify as they choose, TypeDoc doesn't care.\n */\ntype S<T, K extends keyof T> = {\n    -readonly [K2 in K]: T[K2] extends Primitive ? T[K2] : ModelToObject<T[K2]>\n};\n\n// Reflections\n\nexport interface ReflectionGroup extends S<M.ReflectionGroup, 'title' | 'kind' | 'categories'> {\n    children?: M.ReflectionGroup['children'][number]['id'][];\n}\n\nexport interface ReflectionCategory extends S<M.ReflectionCategory, 'title'> {\n    children?: M.ReflectionCategory['children'][number]['id'][];\n}\n\nexport interface ReferenceReflection extends DeclarationReflection, S<M.ReferenceReflection, never> {\n    /**\n     * -1 if the reference refers to a symbol that does not exist in the documentation.\n     * Otherwise, the reflection ID.\n     */\n    target: number;\n}\n\nexport interface SignatureReflection extends Reflection, S<M.SignatureReflection,\n      'type'\n    | 'overwrites'\n    | 'inheritedFrom'\n    | 'implementationOf'> {\n}\n\nexport interface ParameterReflection extends Reflection, S<M.ParameterReflection, 'type' | 'defaultValue'> {\n}\n\nexport interface DeclarationReflection extends ContainerReflection, S<M.DeclarationReflection,\n      'type'\n    | 'defaultValue'\n    | 'overwrites'\n    | 'inheritedFrom'\n    | 'extendedTypes'\n    | 'extendedBy'\n    | 'implementedTypes'\n    | 'implementedBy'\n    | 'implementationOf'> {\n}\n\nexport interface TypeParameterReflection extends Reflection, S<M.TypeParameterReflection, 'type'> {\n}\n\n// Nothing extra yet.\nexport interface ProjectReflection extends ContainerReflection { }\n\nexport interface ContainerReflection extends Reflection, S<M.ContainerReflection, 'groups' | 'categories'> {\n    sources?: ModelToObject<SourceReferenceWrapper[]>;\n}\n\n/**\n * If a 3rd party serializer creates a loop when serializing, a pointer will be created\n * instead of re-serializing the [[DeclarationReflection]]\n */\nexport interface ReflectionPointer extends S<M.Reflection, 'id'> {\n}\n\nexport interface Reflection extends S<M.Reflection,\n      'id'\n    | 'name'\n    | 'kind'\n    | 'kindString'\n    | 'comment'\n    | 'decorates'> {\n    originalName?: M.Reflection['originalName'];\n    flags: ReflectionFlags;\n    decorators?: ModelToObject<DecoratorWrapper[]>;\n\n    children?: ModelToObject<M.Reflection>[];\n    parameters?: ModelToObject<M.Reflection>[];\n    typeParameter?: ModelToObject<M.Reflection>[];\n    signatures?: ModelToObject<M.Reflection>[];\n    indexSignature?: ModelToObject<M.Reflection>[];\n    getSignature?: ModelToObject<M.Reflection>[];\n    setSignature?: ModelToObject<M.Reflection>[];\n}\n\n// Types\n\nexport type SomeType =\n    | ArrayType\n    | ConditionalType\n    | IndexedAccessType\n    | InferredType\n    | IntersectionType\n    | IntrinsicType\n    | PredicateType\n    | ReferenceType\n    | ReflectionType\n    | StringLiteralType\n    | TupleType\n    | TypeOperatorType\n    | TypeParameterType\n    | UnionType\n    | UnknownType;\n\nexport interface ArrayType extends Type, S<M.ArrayType, 'type' | 'elementType'> {\n}\n\nexport interface ConditionalType extends Type, S<M.ConditionalType,\n    'type' | 'checkType' | 'extendsType' | 'trueType' | 'falseType'> {\n\n}\n\nexport interface IndexedAccessType extends Type, S<M.IndexedAccessType, 'type' | 'indexType' | 'objectType'> {\n}\n\nexport interface InferredType extends Type, S<M.InferredType, 'type' | 'name'> {\n}\n\nexport interface IntersectionType extends Type, S<M.IntersectionType, 'type' | 'types'> {\n}\n\nexport interface IntrinsicType extends Type, S<M.IntrinsicType, 'type' | 'name'> {\n}\n\nexport interface QueryType extends Type, S<M.QueryType, 'type' | 'queryType'> {\n}\n\nexport interface PredicateType extends Type, S<M.PredicateType, 'type' | 'name' | 'asserts' | 'targetType'> {\n}\n\nexport interface ReferenceType extends Type, S<M.ReferenceType, 'type' | 'name' | 'typeArguments'> {\n    id?: number;\n}\n\nexport interface ReflectionType extends Type, S<M.ReflectionType, 'type'> {\n    declaration?: ModelToObject<M.ReflectionType['declaration']>;\n}\n\nexport interface StringLiteralType extends Type, S<M.StringLiteralType, 'type' | 'value'> {\n}\n\nexport interface TupleType extends Type, S<M.TupleType, 'type'> {\n    elements?: ModelToObject<M.TupleType['elements']>;\n}\n\nexport interface TypeOperatorType extends Type, S<M.TypeOperatorType, 'type' | 'operator' | 'target'> {\n}\n\nexport interface TypeParameterType extends Type, S<M.TypeParameterType, 'type' | 'name' | 'constraint'> {\n}\n\nexport interface UnionType extends Type, S<M.UnionType, 'type' | 'types'> {\n}\n\nexport interface UnknownType extends Type, S<M.UnknownType, 'type' | 'name'> {\n}\n\n/**\n * Technically not correct, the `type` property will be set by the abstract serializer.\n * But to allow tagged literals, the `type` property is instead defined by each child type.\n */\nexport interface Type {\n}\n\n// Miscellaneous\n\nexport interface ReflectionFlags extends Partial<S<M.ReflectionFlags,\n      'isPrivate'\n    | 'isProtected'\n    | 'isPublic'\n    | 'isStatic'\n    | 'isExported'\n    | 'isExternal'\n    | 'isOptional'\n    | 'isRest'\n    | 'hasExportAssignment'\n    | 'isConstructorProperty'\n    | 'isAbstract'\n    | 'isConst'\n    | 'isLet'>> {\n}\n\nexport interface Comment extends Partial<S<M.Comment, 'shortText' | 'text' | 'returns' | 'tags'>> {\n}\n\nexport interface CommentTag extends S<M.CommentTag, 'text'> {\n    tag: M.CommentTag['tagName'];\n    param?: M.CommentTag['paramName'];\n}\n\nexport interface SourceReference extends S<M.SourceReference, 'fileName' | 'line' | 'character'> {\n}\n\nexport interface Decorator extends S<M.Decorator, 'name' | 'type' | 'arguments'> {\n}\n"]}
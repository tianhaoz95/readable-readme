{"version":3,"file":"application.js","sourceRoot":"","sources":["../../src/lib/application.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * The TypeDoc main module and namespace.\n *\n * The [[Application]] class holds the core logic of the cli application. All code related\n * to resolving reflections is stored in [[TypeDoc.Factories]], the actual data models can be found\n * in [[TypeDoc.Models]] and the final rendering is defined in [[TypeDoc.Output]].\n */\n\nimport * as Path from 'path';\nimport * as FS from 'fs';\nimport * as typescript from 'typescript';\n\nimport { Converter } from './converter/index';\nimport { Renderer } from './output/renderer';\nimport { Serializer } from './serialization';\nimport { ProjectReflection } from './models/index';\nimport { Logger, ConsoleLogger, CallbackLogger, PluginHost, writeFile, readFile } from './utils/index';\nimport { createMinimatch } from './utils/paths';\n\nimport {\n    AbstractComponent,\n    ChildableComponent,\n    Component,\n    DUMMY_APPLICATION_OWNER\n} from './utils/component';\nimport { Options, BindOption } from './utils';\nimport { TypeDocAndTSOptions, TypeDocOptions } from './utils/options/declaration';\n\n/**\n * The default TypeDoc main application class.\n *\n * This class holds the two main components of TypeDoc, the [[Dispatcher]] and\n * the [[Renderer]]. When running TypeDoc, first the [[Dispatcher]] is invoked which\n * generates a [[ProjectReflection]] from the passed in source files. The\n * [[ProjectReflection]] is a hierarchical model representation of the TypeScript\n * project. Afterwards the model is passed to the [[Renderer]] which uses an instance\n * of [[BaseTheme]] to generate the final documentation.\n *\n * Both the [[Dispatcher]] and the [[Renderer]] are subclasses of the [[EventDispatcher]]\n * and emit a series of events while processing the project. Subscribe to these Events\n * to control the application flow or alter the output.\n */\n@Component({ name: 'application', internal: true })\nexport class Application extends ChildableComponent<\n    Application,\n    AbstractComponent<Application>\n> {\n    /**\n     * The converter used to create the declaration reflections.\n     */\n    converter: Converter;\n\n    /**\n     * The renderer used to generate the documentation output.\n     */\n    renderer: Renderer;\n\n    /**\n     * The serializer used to generate JSON output.\n     */\n    serializer: Serializer;\n\n    /**\n     * The logger that should be used to output messages.\n     */\n    logger: Logger;\n\n    options: Options;\n\n    plugins: PluginHost;\n\n    @BindOption('logger')\n    loggerType!: string | Function;\n\n    @BindOption('ignoreCompilerErrors')\n    ignoreCompilerErrors!: boolean;\n\n    @BindOption('exclude')\n    exclude!: Array<string>;\n\n    @BindOption('inputFiles')\n    inputFiles!: string[];\n\n    @BindOption('options')\n    optionsFile!: string;\n\n    @BindOption('tsconfig')\n    project!: string;\n\n    /**\n     * The version number of TypeDoc.\n     */\n    static VERSION = '{{ VERSION }}';\n\n    /**\n     * Create a new TypeDoc application instance.\n     *\n     * @param options An object containing the options that should be used.\n     */\n    constructor() {\n        super(DUMMY_APPLICATION_OWNER);\n\n        this.logger = new ConsoleLogger();\n        this.options = new Options(this.logger);\n        this.options.addDefaultDeclarations();\n        this.serializer = new Serializer();\n        this.converter = this.addComponent<Converter>('converter', Converter);\n        this.renderer  = this.addComponent<Renderer>('renderer', Renderer);\n        this.plugins   = this.addComponent('plugins', PluginHost);\n    }\n\n    /**\n     * Initialize TypeDoc with the given options object.\n     *\n     * @param options  The desired options to set.\n     */\n    bootstrap(options: Partial<TypeDocAndTSOptions> = {}): { hasErrors: boolean, inputFiles: string[] } {\n        for (const [key, val] of Object.entries(options)) {\n            try {\n                this.options.setValue(key as keyof TypeDocOptions, val);\n            } catch {\n                // Ignore errors, plugins haven't been loaded yet and may declare an option.\n            }\n        }\n        this.options.read(new Logger());\n\n        const logger = this.loggerType;\n        if (typeof logger === 'function') {\n            this.logger = new CallbackLogger(<any> logger);\n            this.options.setLogger(this.logger);\n        } else if (logger === 'none') {\n            this.logger = new Logger();\n            this.options.setLogger(this.logger);\n        }\n\n        this.plugins.load();\n\n        this.options.reset();\n        for (const [key, val] of Object.entries(options)) {\n            try {\n                this.options.setValue(key as keyof TypeDocOptions, val);\n            } catch (error) {\n                this.logger.error(error.message);\n            }\n        }\n        this.options.read(this.logger);\n\n        return {\n            hasErrors: this.logger.hasErrors(),\n            inputFiles: this.inputFiles\n        };\n    }\n\n    /**\n     * Return the application / root component instance.\n     */\n    get application(): Application {\n        return this;\n    }\n\n    /**\n     * Return the path to the TypeScript compiler.\n     */\n    public getTypeScriptPath(): string {\n        return Path.dirname(require.resolve('typescript'));\n    }\n\n    public getTypeScriptVersion(): string {\n        const tsPath = this.getTypeScriptPath();\n        const json = JSON.parse(readFile(Path.join(tsPath, '..', 'package.json')));\n        return json.version;\n    }\n\n    /**\n     * Run the converter for the given set of files and return the generated reflections.\n     *\n     * @param src  A list of source that should be compiled and converted.\n     * @returns An instance of ProjectReflection on success, undefined otherwise.\n     */\n    public convert(src: string[]): ProjectReflection | undefined {\n        this.logger.writeln(\n            'Using TypeScript %s from %s',\n            this.getTypeScriptVersion(),\n            this.getTypeScriptPath()\n        );\n\n        const result = this.converter.convert(src);\n        if (result.errors && result.errors.length) {\n            this.logger.diagnostics(result.errors);\n            if (this.ignoreCompilerErrors) {\n                this.logger.resetErrors();\n                return result.project;\n            } else {\n                return;\n            }\n        } else {\n            return result.project;\n        }\n    }\n\n    /**\n     * @param src  A list of source files whose documentation should be generated.\n     */\n    public generateDocs(src: string[], out: string): boolean;\n\n    /**\n     * @param project  The project the documentation should be generated for.\n     */\n    public generateDocs(project: ProjectReflection, out: string): boolean;\n\n    /**\n     * Run the documentation generator for the given set of files.\n     *\n     * @param out  The path the documentation should be written to.\n     * @returns TRUE if the documentation could be generated successfully, otherwise FALSE.\n     */\n    public generateDocs(input: ProjectReflection | string[], out: string): boolean {\n        const project = input instanceof ProjectReflection ? input : this.convert(input);\n        if (!project) {\n            return false;\n        }\n\n        out = Path.resolve(out);\n        this.renderer.render(project, out);\n        if (this.logger.hasErrors()) {\n            this.logger.error('Documentation could not be generated due to the errors above.');\n        } else {\n            this.logger.success('Documentation generated at %s', out);\n        }\n\n        return true;\n    }\n\n    /**\n     * @param src  A list of source that should be compiled and converted.\n     */\n    public generateJson(src: string[], out: string): boolean;\n\n    /**\n     * @param project  The project that should be converted.\n     */\n    public generateJson(project: ProjectReflection, out: string): boolean;\n\n    /**\n     * Run the converter for the given set of files and write the reflections to a json file.\n     *\n     * @param out  The path and file name of the target file.\n     * @returns TRUE if the json file could be written successfully, otherwise FALSE.\n     */\n    public generateJson(input: ProjectReflection | string[], out: string): boolean {\n        const project = input instanceof ProjectReflection ? input : this.convert(input);\n        if (!project) {\n            return false;\n        }\n\n        out = Path.resolve(out);\n        const eventData = { outputDirectory: Path.dirname(out), outputFile: Path.basename(out) };\n        const ser = this.serializer.projectToObject(project, { begin: eventData, end: eventData });\n        writeFile(out, JSON.stringify(ser, null, '\\t'), false);\n        this.logger.success('JSON written to %s', out);\n\n        return true;\n    }\n\n    /**\n     * Expand a list of input files.\n     *\n     * Searches for directories in the input files list and replaces them with a\n     * listing of all TypeScript files within them. One may use the ```--exclude``` option\n     * to filter out files with a pattern.\n     *\n     * @param inputFiles  The list of files that should be expanded.\n     * @returns  The list of input files with expanded directories.\n     */\n    public expandInputFiles(inputFiles: string[] = []): string[] {\n        const files: string[] = [];\n\n        const exclude = this.exclude ? createMinimatch(this.exclude) : [];\n\n        function isExcluded(fileName: string): boolean {\n            return exclude.some(mm => mm.match(fileName));\n        }\n\n        const includeJson = this.options.getCompilerOptions().resolveJsonModule;\n        const supportedFileRegex = this.options.getCompilerOptions().allowJs ? /\\.[tj]sx?$/ : /\\.tsx?$/;\n        function add(file: string, entryPoint: boolean) {\n            let stats: FS.Stats;\n            try {\n                stats = FS.statSync(file);\n            } catch {\n                // No permission or a symbolic link, do not resolve.\n                return;\n            }\n            const fileIsDir = stats.isDirectory();\n            if (fileIsDir && !file.endsWith('/')) {\n                file = `${file}/`;\n            }\n\n            if ((!fileIsDir || !entryPoint) && isExcluded(file.replace(/\\\\/g, '/'))) {\n                return;\n            }\n\n            if (fileIsDir) {\n                FS.readdirSync(file).forEach(next => {\n                    add(Path.join(file, next), false);\n                });\n            } else if (supportedFileRegex.test(file)) {\n                files.push(file);\n            } else if (includeJson && file.endsWith('.json')) {\n                files.push(file);\n            }\n        }\n\n        inputFiles.forEach(file => {\n            add(Path.resolve(file), true);\n        });\n\n        return files;\n    }\n\n    /**\n     * Print the version number.\n     */\n    toString() {\n        return [\n            '',\n            `TypeDoc ${Application.VERSION}`,\n            `Using TypeScript ${this.getTypeScriptVersion()} from ${this.getTypeScriptPath()}`,\n            ''\n        ].join(typescript.sys.newLine);\n    }\n}\n"]}
{"version":3,"file":"application.js","sourceRoot":"","sources":["../../src/lib/application.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Path from \"path\";\nimport * as FS from \"fs\";\nimport * as ts from \"typescript\";\n\nimport { Converter } from \"./converter/index\";\nimport { Renderer } from \"./output/renderer\";\nimport { Serializer } from \"./serialization\";\nimport { ProjectReflection } from \"./models/index\";\nimport {\n    Logger,\n    ConsoleLogger,\n    CallbackLogger,\n    PluginHost,\n    normalizePath,\n} from \"./utils/index\";\nimport { createMinimatch } from \"./utils/paths\";\n\nimport {\n    AbstractComponent,\n    ChildableComponent,\n    Component,\n    DUMMY_APPLICATION_OWNER,\n} from \"./utils/component\";\nimport { Options, BindOption } from \"./utils\";\nimport { TypeDocOptions } from \"./utils/options/declaration\";\nimport { flatMap } from \"./utils/array\";\nimport { basename } from \"path\";\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst packageInfo = require(\"../../package.json\") as {\n    version: string;\n    peerDependencies: { typescript: string };\n};\n\nconst supportedVersionMajorMinor = packageInfo.peerDependencies.typescript\n    .split(\"||\")\n    .map((version) => version.replace(/^\\s*|\\.x\\s*$/g, \"\"));\n\n/**\n * The default TypeDoc main application class.\n *\n * This class holds the two main components of TypeDoc, the [[Converter]] and\n * the [[Renderer]]. When running TypeDoc, first the [[Converter]] is invoked which\n * generates a [[ProjectReflection]] from the passed in source files. The\n * [[ProjectReflection]] is a hierarchical model representation of the TypeScript\n * project. Afterwards the model is passed to the [[Renderer]] which uses an instance\n * of [[BaseTheme]] to generate the final documentation.\n *\n * Both the [[Converter]] and the [[Renderer]] are subclasses of the [[AbstractComponent]]\n * and emit a series of events while processing the project. Subscribe to these Events\n * to control the application flow or alter the output.\n */\n@Component({ name: \"application\", internal: true })\nexport class Application extends ChildableComponent<\n    Application,\n    AbstractComponent<Application>\n> {\n    /**\n     * The converter used to create the declaration reflections.\n     */\n    converter: Converter;\n\n    /**\n     * The renderer used to generate the documentation output.\n     */\n    renderer: Renderer;\n\n    /**\n     * The serializer used to generate JSON output.\n     */\n    serializer: Serializer;\n\n    /**\n     * The logger that should be used to output messages.\n     */\n    logger: Logger;\n\n    options: Options;\n\n    plugins: PluginHost;\n\n    @BindOption(\"logger\")\n    loggerType!: string | Function;\n\n    @BindOption(\"exclude\")\n    exclude!: Array<string>;\n\n    @BindOption(\"entryPoints\")\n    entryPoints!: string[];\n\n    @BindOption(\"options\")\n    optionsFile!: string;\n\n    @BindOption(\"tsconfig\")\n    project!: string;\n\n    /**\n     * The version number of TypeDoc.\n     */\n    static VERSION = packageInfo.version;\n\n    /**\n     * Create a new TypeDoc application instance.\n     *\n     * @param options An object containing the options that should be used.\n     */\n    constructor() {\n        super(DUMMY_APPLICATION_OWNER);\n\n        this.logger = new ConsoleLogger();\n        this.options = new Options(this.logger);\n        this.options.addDefaultDeclarations();\n        this.serializer = new Serializer();\n        this.converter = this.addComponent<Converter>(\"converter\", Converter);\n        this.renderer = this.addComponent<Renderer>(\"renderer\", Renderer);\n        this.plugins = this.addComponent(\"plugins\", PluginHost);\n    }\n\n    /**\n     * Initialize TypeDoc with the given options object.\n     *\n     * @param options  The desired options to set.\n     */\n    bootstrap(options: Partial<TypeDocOptions> = {}): void {\n        for (const [key, val] of Object.entries(options)) {\n            try {\n                this.options.setValue(key as keyof TypeDocOptions, val);\n            } catch {\n                // Ignore errors, plugins haven't been loaded yet and may declare an option.\n            }\n        }\n        this.options.read(new Logger());\n\n        const logger = this.loggerType;\n        if (typeof logger === \"function\") {\n            this.logger = new CallbackLogger(<any>logger);\n            this.options.setLogger(this.logger);\n        } else if (logger === \"none\") {\n            this.logger = new Logger();\n            this.options.setLogger(this.logger);\n        }\n        this.logger.level = this.options.getValue(\"logLevel\");\n\n        this.plugins.load();\n\n        this.options.reset();\n        for (const [key, val] of Object.entries(options)) {\n            try {\n                this.options.setValue(key as keyof TypeDocOptions, val);\n            } catch (error) {\n                this.logger.error(error.message);\n            }\n        }\n        this.options.read(this.logger);\n    }\n\n    /**\n     * Return the application / root component instance.\n     */\n    get application(): Application {\n        return this;\n    }\n\n    /**\n     * Return the path to the TypeScript compiler.\n     */\n    public getTypeScriptPath(): string {\n        return Path.dirname(require.resolve(\"typescript\"));\n    }\n\n    public getTypeScriptVersion(): string {\n        return ts.version;\n    }\n\n    /**\n     * Run the converter for the given set of files and return the generated reflections.\n     *\n     * @param src  A list of source that should be compiled and converted.\n     * @returns An instance of ProjectReflection on success, undefined otherwise.\n     */\n    public convert(): ProjectReflection | undefined {\n        this.logger.verbose(\n            \"Using TypeScript %s from %s\",\n            this.getTypeScriptVersion(),\n            this.getTypeScriptPath()\n        );\n\n        if (\n            !supportedVersionMajorMinor.some(\n                (version) => version == ts.versionMajorMinor\n            )\n        ) {\n            this.logger.warn(\n                `You are running with an unsupported TypeScript version! TypeDoc supports ${supportedVersionMajorMinor.join(\n                    \", \"\n                )}`\n            );\n        }\n\n        if (Object.keys(this.options.getCompilerOptions()).length === 0) {\n            this.logger.warn(\n                `No compiler options set. This likely means that TypeDoc did not find your tsconfig.json. Generated documentation will probably be empty.`\n            );\n        }\n\n        const programs = [\n            ts.createProgram({\n                rootNames: this.application.options.getFileNames(),\n                options: this.application.options.getCompilerOptions(),\n                projectReferences: this.application.options.getProjectReferences(),\n            }),\n        ];\n\n        // This might be a solution style tsconfig, in which case we need to add a program for each\n        // reference so that the converter can look through each of these.\n        if (programs[0].getRootFileNames().length === 0) {\n            this.logger.verbose(\n                \"tsconfig appears to be a solution style tsconfig - creating programs for references\"\n            );\n            const resolvedReferences = programs[0].getResolvedProjectReferences();\n            for (const ref of resolvedReferences ?? []) {\n                if (!ref) continue; // This indicates bad configuration... will be reported later.\n\n                programs.push(\n                    ts.createProgram({\n                        options: ref.commandLine.options,\n                        rootNames: ref.commandLine.fileNames,\n                        projectReferences: ref.commandLine.projectReferences,\n                    })\n                );\n            }\n        }\n\n        this.logger.verbose(`Converting with ${programs.length} programs`);\n\n        const errors = flatMap(programs, ts.getPreEmitDiagnostics);\n        if (errors.length) {\n            this.logger.diagnostics(errors);\n            return;\n        }\n\n        if (this.application.options.getValue(\"emit\")) {\n            for (const program of programs) {\n                program.emit();\n            }\n        }\n\n        return this.converter.convert(\n            this.expandInputFiles(this.entryPoints),\n            programs\n        );\n    }\n\n    public convertAndWatch(\n        success: (project: ProjectReflection) => Promise<void>\n    ): void {\n        if (\n            !this.options.getValue(\"preserveWatchOutput\") &&\n            this.logger instanceof ConsoleLogger\n        ) {\n            ts.sys.clearScreen?.();\n        }\n\n        this.logger.verbose(\n            \"Using TypeScript %s from %s\",\n            this.getTypeScriptVersion(),\n            this.getTypeScriptPath()\n        );\n\n        if (\n            !supportedVersionMajorMinor.some(\n                (version) => version == ts.versionMajorMinor\n            )\n        ) {\n            this.logger.warn(\n                `You are running with an unsupported TypeScript version! TypeDoc supports ${supportedVersionMajorMinor.join(\n                    \", \"\n                )}`\n            );\n        }\n\n        if (Object.keys(this.options.getCompilerOptions()).length === 0) {\n            this.logger.warn(\n                `No compiler options set. This likely means that TypeDoc did not find your tsconfig.json. Generated documentation will probably be empty.`\n            );\n        }\n\n        // Doing this is considerably more complicated, we'd need to manage an array of programs, not convert until all programs\n        // have reported in the first time... just error out for now. I'm not convinced anyone will actually notice.\n        if (this.application.options.getFileNames().length === 0) {\n            this.logger.error(\n                \"The provided tsconfig file looks like a solution style tsconfig, which is not supported in watch mode.\"\n            );\n            return;\n        }\n\n        // Matches the behavior of the tsconfig option reader.\n        let tsconfigFile = this.options.getValue(\"tsconfig\");\n        tsconfigFile =\n            ts.findConfigFile(\n                tsconfigFile,\n                ts.sys.fileExists,\n                tsconfigFile.toLowerCase().endsWith(\".json\")\n                    ? basename(tsconfigFile)\n                    : undefined\n            ) ?? \"tsconfig.json\";\n\n        // We don't want to do it the first time to preserve initial debug status messages. They'll be lost\n        // after the user saves a file, but better than nothing...\n        let firstStatusReport = true;\n\n        const host = ts.createWatchCompilerHost(\n            tsconfigFile,\n            { noEmit: !this.application.options.getValue(\"emit\") },\n            ts.sys,\n            ts.createEmitAndSemanticDiagnosticsBuilderProgram,\n            (diagnostic) => this.logger.diagnostic(diagnostic),\n            (status, newLine, _options, errorCount) => {\n                if (\n                    !firstStatusReport &&\n                    errorCount === void 0 &&\n                    !this.options.getValue(\"preserveWatchOutput\") &&\n                    this.logger instanceof ConsoleLogger\n                ) {\n                    ts.sys.clearScreen?.();\n                }\n                firstStatusReport = false;\n                this.logger.write(\n                    ts.flattenDiagnosticMessageText(status.messageText, newLine)\n                );\n            }\n        );\n\n        let successFinished = true;\n        let currentProgram: ts.Program | undefined;\n\n        const runSuccess = () => {\n            if (!currentProgram) {\n                return;\n            }\n\n            if (successFinished) {\n                this.logger.resetErrors();\n                const project = this.converter.convert(\n                    this.expandInputFiles(this.entryPoints),\n                    currentProgram\n                );\n                currentProgram = undefined;\n                successFinished = false;\n                success(project).then(() => {\n                    successFinished = true;\n                    runSuccess();\n                });\n            }\n        };\n\n        const origAfterProgramCreate = host.afterProgramCreate;\n        host.afterProgramCreate = (program) => {\n            if (ts.getPreEmitDiagnostics(program.getProgram()).length === 0) {\n                currentProgram = program.getProgram();\n                runSuccess();\n            }\n            origAfterProgramCreate?.(program);\n        };\n\n        ts.createWatchProgram(host);\n    }\n\n    /**\n     * Render HTML for the given project\n     */\n    public async generateDocs(\n        project: ProjectReflection,\n        out: string\n    ): Promise<void> {\n        out = Path.resolve(out);\n        await this.renderer.render(project, out);\n        if (this.logger.hasErrors()) {\n            this.logger.error(\n                \"Documentation could not be generated due to the errors above.\"\n            );\n        } else {\n            this.logger.success(\"Documentation generated at %s\", out);\n        }\n    }\n\n    /**\n     * Run the converter for the given set of files and write the reflections to a json file.\n     *\n     * @param out  The path and file name of the target file.\n     * @returns TRUE if the json file could be written successfully, otherwise FALSE.\n     */\n    public async generateJson(\n        project: ProjectReflection,\n        out: string\n    ): Promise<void> {\n        out = Path.resolve(out);\n        const eventData = {\n            outputDirectory: Path.dirname(out),\n            outputFile: Path.basename(out),\n        };\n        const ser = this.serializer.projectToObject(project, {\n            begin: eventData,\n            end: eventData,\n        });\n        await FS.promises.writeFile(out, JSON.stringify(ser, null, \"\\t\"));\n        this.logger.success(\"JSON written to %s\", out);\n    }\n\n    /**\n     * Expand a list of input files.\n     *\n     * Searches for directories in the input files list and replaces them with a\n     * listing of all TypeScript files within them. One may use the ```--exclude``` option\n     * to filter out files with a pattern.\n     *\n     * @param inputFiles  The list of files that should be expanded.\n     * @returns  The list of input files with expanded directories.\n     */\n    public expandInputFiles(inputFiles: readonly string[]): string[] {\n        const files: string[] = [];\n\n        const exclude = createMinimatch(this.exclude);\n\n        function isExcluded(fileName: string): boolean {\n            return exclude.some((mm) => mm.match(fileName));\n        }\n\n        const supportedFileRegex =\n            this.options.getCompilerOptions().allowJs ||\n            this.options.getCompilerOptions().checkJs\n                ? /\\.[tj]sx?$/\n                : /\\.tsx?$/;\n        function add(file: string, entryPoint: boolean) {\n            let stats: FS.Stats;\n            try {\n                stats = FS.statSync(file);\n            } catch {\n                // No permission or a symbolic link, do not resolve.\n                return;\n            }\n            const fileIsDir = stats.isDirectory();\n            if (fileIsDir && !file.endsWith(\"/\")) {\n                file = `${file}/`;\n            }\n\n            if (!entryPoint && isExcluded(normalizePath(file))) {\n                return;\n            }\n\n            if (fileIsDir) {\n                FS.readdirSync(file).forEach((next) => {\n                    add(Path.join(file, next), false);\n                });\n            } else if (supportedFileRegex.test(file)) {\n                files.push(normalizePath(file));\n            }\n        }\n\n        inputFiles.forEach((file) => {\n            const resolved = Path.resolve(file);\n            if (!FS.existsSync(resolved)) {\n                this.logger.warn(\n                    `Provided entry point ${file} does not exist and will not be included in the docs.`\n                );\n                return;\n            }\n\n            add(resolved, true);\n        });\n\n        return files;\n    }\n\n    /**\n     * Print the version number.\n     */\n    toString() {\n        return [\n            \"\",\n            `TypeDoc ${Application.VERSION}`,\n            `Using TypeScript ${this.getTypeScriptVersion()} from ${this.getTypeScriptPath()}`,\n            \"\",\n        ].join(\"\\n\");\n    }\n}\n"]}